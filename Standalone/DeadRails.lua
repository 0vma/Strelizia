-- // you can skid this but i wouldn't recommend since it's all stripped down for performance

local a local aa={function()local b, c, d=a(1)return(function(...) if(not game:IsLoaded())then game.Loaded:Wait() end if Fluent then Fluent.Destroy()end local e=d(c.Library); e.Debug=true; local f=e.Libraries local g=f.Game local h= g.GameModules local i=f.General local j=i.Cache local k= i.InfoLibrary local l=i.LRM_Variables local m= i.Actions local n=i.Interface.Get() local o=i.Tree local p= i.Promise local q= i.Signal local r=i.Threading local s=i.Services local t= i.Trove local u=e.Functions local v=u.Game local w=u.General local x=s.Players local y= s.RunService local z=s.Workspace local A=s.ReplicatedStorage local B= s.UserInputService local C=s.GuiService local D=x.LocalPlayer local E=j.Get'ScriptCache'; E.InitTime=DateTime.now().UnixTimestamp local F=n.Fluent local G=n.SaveManager local H=n.ThemeManager getgenv().Fluent=F local I=w.GetGameInfo(game.PlaceId) local J=F:CreateWindow{ Title=string.format('strelizia.cc | %s',I and I.Name or"?"), SubTitle="v"..l.LRM_ScriptVersion, TabWidth=120, Size=UDim2.fromOffset(600,480), Resize=true, MinSize=Vector2.new(430,350), Acrylic=false, Theme="VSC Dark High Contrast", MinimizeKey=Enum.KeyCode.RightControl } local K={ Home=J:CreateTab{ Title="Home", Icon="house" }, Visuals=J:CreateTab{ Title="Visuals", Icon="eye" }, Combat=J:CreateTab{ Title="Combat", Icon="swords" }, Misc=J:CreateTab{ Title="Others", Icon="circle-ellipsis" }, Settings=J:CreateTab{ Title="Settings", Icon="settings" }, } local L={ Home_Information=K.Home:AddSection"↳ Information", Home_Credits=K.Home:AddSection"↳ Credits", Visuals_General=K.Visuals:AddSection"↳ General", Visuals_Item=K.Visuals:AddSection"↳ Items", Visuals_Enemies=K.Visuals:AddSection"↳ Enemies", Visuals_Players=K.Visuals:AddSection"↳ Players", Combat_Melee=K.Combat:AddSection"↳ Melee", Combat_Guns=K.Combat:AddSection"↳ Guns", Misc_Others=K.Misc:AddSection"↳ Others" } do local M=L.Home_Information:CreateParagraph("ClientUptimeParagraph",{ Title="Client Uptime: nil", TitleAlignment=Enum.TextXAlignment.Center, }); r.New("ClientUptimeParagraph",function(N) while F.Loaded and task.wait(1)do M.Instance.TitleLabel.Text=string.format("Script Uptime: %s",w.FormatHms(w.GetUptime())) end end):Start() local N=L.Home_Information:CreateParagraph("LuaHeapParagraph",{ Title="Lua Heap (Megabytes): nil", TitleAlignment=Enum.TextXAlignment.Center, }); r.New("LuaHeapParagraph",function(O) while F.Loaded and task.wait(1)do N.Instance.TitleLabel.Text=string.format('Lua Heap: %sMB', tostring(w.CommaNumber(math.ceil(gcinfo()/1000)))) end end):Start() L.Home_Information:CreateButton{ Title="Join Discord", Description="prompts discord invite if the user is on pc, copies to clipboard otherwise", Callback=function() w.PromptDiscordJoin('Vf4Wu3Cft7',true) F:Notify{ Title="Discord Prompted/Copied", Content="discord invite has been prompted/copied to your clipboard!", Duration=2 } end } L.Home_Credits:CreateParagraph("CreditsVma",{ Title="vma", TitleAlignment=Enum.TextXAlignment.Center, Content="Role: Main Developer\nDiscord: @fwvma", ContentAlignment=Enum.TextXAlignment.Center }); L.Home_Credits:CreateParagraph("CreditsPryxo",{ Title="Pryxo", TitleAlignment=Enum.TextXAlignment.Center, Content="Role: Main Developer\nDiscord: @pryxo", ContentAlignment=Enum.TextXAlignment.Center }); L.Home_Credits:CreateParagraph("CreditsFelix",{ Title="Felix", TitleAlignment=Enum.TextXAlignment.Center, Content="Role: Main Developer\nDiscord: @felixdm", ContentAlignment=Enum.TextXAlignment.Center }); L.Home_Credits:CreateParagraph("CreditsOogway",{ Title="Master Oogway", TitleAlignment=Enum.TextXAlignment.Center, Content="Role: UI Designer\nDiscord: @realmasteroogway", ContentAlignment=Enum.TextXAlignment.Center }); end do local M=L.Visuals_General:CreateSlider("MaximumVisualDistance",{ Title="Maximum Distance", Description="(0 = infinite)", Default=600, Min=0, Max=3000, Rounding=1, }) local N={} local function O(P) local Q=N[P]; if Q then pcall(Q.Destroy,Q); N[P]=nil; end end local P=L.Visuals_Item:CreateToggle("ItemVisualsText",{Title="Item Text",Default=false,Description="displays item information such as name, distance, price"}); P:OnChanged(function(Q) if(not Q)then r.TerminateById'ItemVisualsText' return end r.New('ItemVisualsText',function(R) while F.Loaded and task.wait()do for S,T in workspace.RuntimeItems:GetChildren()do if(not T:IsA'Model')then continue end local U=T.PrimaryPart; if(not U)then O(T)continue end local V=N[T]; if V then local W,X=workspace.CurrentCamera:WorldToViewportPoint(U.Position); local Y=math.ceil(D:DistanceFromCharacter(U.Position)or math.huge); local Z=M.Value local _=T:GetAttribute'Value' V.Visible=X and(Z==0 or Y<=Z) if X then V.Position=Vector2.new(W.X,W.Y) V.Text="Name: "..T.Name.." | Distance: "..Y..(_ and" | Price: "..w.CommaNumber(_).."$"or"") V.Color=U.Color end else N[T]=v.CreateTextEsp{Stroke=true} R:AddConnection(T.AncestryChanged:Once(function() O(T) end)) end end end end):AddCleanupFunction(function() for R,S in N do pcall(S.Destroy,S) N[R]=nil end end):Start() end) local Q={} local R=L.Visuals_Item:CreateToggle("ItemBoundingBox",{Title="Item Bounding Box",Default=false,Description="creates a bounding box around the item"}); R:OnChanged(function(S) if(not S)then r.TerminateById'ItemBoundingBox' return end r.New('ItemBoundingBox',function(T) while F.Loaded and task.wait(1)do for U,V in workspace.RuntimeItems:GetChildren()do if(not V:IsA'Model')then continue end local W=V.PrimaryPart if(not W)then continue end local X=Q[V] if X then local Y=D:DistanceFromCharacter(W.Position); local Z=M.Value X.Visible=Z==0 or(Y<=Z) continue end;local Y, Z=V:GetBoundingBox(); local _=v.CreateBoundingBox{ Parent=V, Color3=W.Color, Adornee=V, Size=Z*1.2, Transparency=0.3, AlwaysOnTop=true, ZIndex=1, }; Q[V]=_ end end end):AddCleanupFunction(function() for T,U in Q do pcall(U.Destroy,U) Q[T]=nil end end):Start() end) local S={} local function T(U) local V=S[U]; if V then pcall(V.Destroy,V); S[U]=nil; end end local U=L.Visuals_Enemies:CreateToggle("EnemyVisualsText",{Title="Enemy Text",Default=false,Description="displays information about enemies such as name, distance, health"}); U:OnChanged(function(V) if(not V)then r.TerminateById'EnemyVisualsText' return end r.New('EnemyVisualsText',function(W) while F.Loaded and task.wait()do for X,Y in v.GetEnemies()do if(not Y:IsA'Model')then continue end local Z=Y.PrimaryPart if(not Z)then T(Y)continue end local _=Y:FindFirstChild'Humanoid'; if(not _)then T(Y)continue end local aa=S[Y]; if aa then local ab,ac=workspace.CurrentCamera:WorldToViewportPoint(Z.Position); local ad=math.ceil(D:DistanceFromCharacter(Z.Position)or math.huge); local ae=M.Value aa.Visible=ac and(ae==0 or ad<=ae)and _.Health>0 if ac then aa.Position=Vector2.new(ab.X,ab.Y) aa.Text=string.format('Name: %s | Health: %s | Distance: %s', tostring(Y.Name), tostring(math.ceil(_.Health)), tostring(ad)) aa.Color=Z.Color end else S[Y]=v.CreateTextEsp{Stroke=true} W:AddConnection(Y.AncestryChanged:Once(function() T(Y) end)) end end end end):AddCleanupFunction(function() for aa,ab in S do pcall(ab.Destroy,ab) S[aa]=nil end end):Start() end) local aa={} local ab=L.Visuals_Enemies:CreateToggle("EnemyBoundingBox",{Title="Enemy Bounding Box",Default=false,Description="creates a bounding box around the enemy"}); ab:OnChanged(function(ac) if(not ac)then r.TerminateById'EnemyBoundingBox' return end r.New('EnemyBoundingBox',function(ad) while F.Loaded and task.wait(1)do for ae,V in v.GetEnemies()do if(not V:IsA'Model')then continue end if(not V.PrimaryPart)then continue end local W=V:FindFirstChild'Humanoid'; if(not W)then continue end local X=aa[V] if X then local Y=D:DistanceFromCharacter(V.PrimaryPart.Position); local Z=M.Value X.Visible=(Z==0 or(Y<=Z))and W.Health>0 continue end;local Y, Z=V:GetBoundingBox(); local _=v.CreateBoundingBox{ Parent=V, Color3=V.PrimaryPart.Color, Adornee=V, Size=Z, Transparency=0.7, AlwaysOnTop=true, ZIndex=1, }; ad:AddConnection(V.AncestryChanged:Once(function() local af=aa[V] if af then pcall(af.Destroy,af) aa[V]=nil end end)) aa[V]=_ end end end):AddCleanupFunction(function() for ad,ae in aa do pcall(ae.Destroy,ae) aa[ad]=nil end end):Start() end) local ac={} local ad=L.Visuals_Players:CreateToggle("PlayerVisualsText",{Title="Player Text",Default=false,Description="displays information about players such as name, health, distance"}); ad:OnChanged(function(ae) if(not ae)then r.TerminateById'PlayerVisualsText' return end r.New('PlayerVisualsText',function(af) while F.Loaded and task.wait()do for V,W in x:GetPlayers()do if W==D then continue end local X=W.Character if(not X)then continue end local Y=X:FindFirstChild"Humanoid"; if(not Y)then continue end local Z=ac[W]; if Z then local _,ag=workspace.CurrentCamera:WorldToViewportPoint(X.PrimaryPart.Position); local ah=math.ceil(D:DistanceFromCharacter(X.PrimaryPart.Position)or math.huge); local ai=M.Value Z.Visible=ag and(ai==0 or ah<=ai) if ag then Z.Position=Vector2.new(_.X,_.Y) Z.Text=string.format('Name: %s | Health: %s | Distance: %s', tostring(W.Name), tostring(math.ceil(Y.Health)), tostring(ah)) Z.Color=Color3.fromRGB(255,255,255) end else ac[W]=v.CreateTextEsp{Stroke=true} af:AddConnection(W.AncestryChanged:Once(function() local ag=ac[W]; if ag then pcall(ag.Destroy,ag); ac[W]=nil; end end)) end end end end):AddCleanupFunction(function() for af,ag in ac do pcall(ag.Destroy,ag) ac[af]=nil end end):Start() end) local ae={}; local af=L.Visuals_Players:CreateToggle("PlayerHighlightText",{Title="Player Highlight",Default=false,Description="highlights players body"}); af:OnChanged(function(ag) if(not ag)then r.TerminateById'PlayerHighlightText' return end r.New('PlayerHighlightText',function(ah) while F.Loaded and task.wait(1)do for ai,V in x:GetPlayers()do if V==D then continue end local W=V.Character if(not W)then continue end local X=W:FindFirstChild"Humanoid"; if(not X)then continue end local Y=ae[V] if Y then local Z=D:DistanceFromCharacter(W.PrimaryPart.Position); local _=M.Value Y.Enabled=(_==0 or(Z<=_))and X.Health>0 Y.FillColor=(F.Options.PlayerHighlightColor.Value or Color3.fromRGB(255,0,0)) continue end; local Z=v.CreateHighlight{ Parent=W, FillColor=(F.Options.PlayerHighlightColor.Value or Color3.fromRGB(255,0,0)), Adornee=W, FillTransparency=0.6, DepthMode=Enum.HighlightDepthMode.AlwaysOnTop, }; ah:AddConnection(V.Destroying:Once(function() local _=ae[V]; if _ then pcall(_.Destroy,_); ae[V]=nil end end)) ae[V]=Z end end end):AddCleanupFunction(function() for ah,ai in ae do pcall(ai.Destroy,ai) ae[ah]=nil end end):Start() end) L.Visuals_Players:CreateColorpicker("PlayerHighlightColor",{ Title="Player Highlight Color", Default=Color3.fromRGB(255,0,0) }) end do local aa=L.Combat_Melee:CreateToggle("MeleeAuraToggle",{Title="Melee Aura",Default=false,Description="automatically attacks nearby enemies (if you have a melee weapon equipped)"}); aa:OnChanged(function(ab) if(not ab)then r.TerminateById'MeleeAuraToggle' return end r.New('MeleeAuraToggle',function(ac) while F.Loaded and task.wait(0.25)do local ad=D.Character; if(not ad)then continue end local ae=ad:FindFirstChildWhichIsA'Tool'; if(not ae)or(not ae:FindFirstChild'SwingEvent')then continue end local af,ag=v.GetNearestEnemy(); if(not af)or ag>10 then continue end local ah=(ad.PrimaryPart.Position-af.PrimaryPart.Position).Unit*100; ae:FindFirstChild'SwingEvent':FireServer( vector.create(ah.X,ah.Y,ah.Z) ); end end):Start() end) w.AssertFunctions({'hookmetamethod','getrawmetatable','hookfunction'},function() local ab local ac=L.Combat_Guns:CreateToggle("SilentAimToggle",{Title="Silent Aim",Default=false,Description="bullets will automatically curve towards nearest enemy"}); local ad=L.Combat_Guns:CreateSlider("SilentAimFieldOfView",{ Title="Field of View", Description="silent aim fov", Default=70, Min=1, Max=180, Rounding=1, }) ad:OnChanged(function(ae) if ab then ab.Radius=ae end end) local ae=L.Combat_Guns:CreateToggle("DrawFOV",{Title="Visualize Field of View",Default=false,Description="visualizes fov on ur screen"}); ae:OnChanged(function(af) if ab then ab.Visible=af ab.Position=Vector2.new(z.CurrentCamera.ViewportSize.X/2,z.CurrentCamera.ViewportSize.Y/2-(C:GetGuiInset().Y/2)) else ab=Drawing.new'Circle' ab.Radius=ad.Value ab.Color=Color3.fromRGB(255,255,255) ab.Filled=false ab.NumSides=360 ab.Position=Vector2.new(z.CurrentCamera.ViewportSize.X/2,z.CurrentCamera.ViewportSize.Y/2-(C:GetGuiInset().Y/2)) ab.Visible=af end end) local af; local ag=o.Find(A.Remotes,'Weapon/Shoot'); af=hookmetamethod(game,"__namecall",newcclosure(function(ah,...) local ai=getnamecallmethod(); if ai=='FireServer'and ah==ag and ac.Value then local M,N,O,P=...; local Q,R=v.GetNearestEnemyToMouse(ad.Value); if Q then print(string.format('Closest enemy to Mouse: %s (Distance: %s)', tostring(Q.Name), tostring(math.floor(R)))) P={ ["1"]=Q:FindFirstChild'Humanoid' } O=CFrame.lookAt(O.Position,Q.Head.Position) end setnamecallmethod'FireServer' return af(ah,M,N,O,P) end return af(ah,...) end)) end) end do local aa=L.Misc_Others:CreateToggle("AntiAfkToggle",{Title="Anti AFK",Default=false,Description="prevents you from getting afk kicked"}); aa:OnChanged(w.AntiAFK) end do G:SetLibrary(F) H:SetLibrary(F) G:IgnoreThemeSettings() G:SetIgnoreIndexes{} H:SetFolder"StreliziaScriptHub" G:SetFolder("StreliziaScriptHub/"..game.PlaceId) H:BuildInterfaceSection(K.Settings) G:BuildConfigSection(K.Settings) J:SelectTab(1) F:Notify{ Title="strelizia.cc", Content="script loaded, enjoy <3", Duration=5 } F:ToggleTransparency(false) G:LoadAutoloadConfig() F.OnUnload:Connect(function() r.TerminateAll() if game:GetService'CoreGui':FindFirstChild"UIToggle"then game:GetService'CoreGui':FindFirstChild"UIToggle":Destroy() end end) do r.New('DiscordJoinPrompt',function(aa) local ab=120 while true do local ac,ad=pcall(isfile,'StreliziaJoinedDiscord'); if ac and ad==true then break end; task.wait(ab) ab=ab*3 local ae=J:Dialog{ Title="Discord", Content="Hey! Want to join our Discord for tons of giveaways, stay updated on script status, and hang out with the community?", Buttons={ { Title="Sure", Callback=function()w.PromptDiscordJoin('Vf4Wu3Cft7',true)pcall(writefile,'StreliziaJoinedDiscord','true')end }, { Title="No", Callback=function()end } } } ae.Closed:Wait() end end):Start() end end end)()end,function()local aa, ab, ac=a(2)return(function(...)local ad={} function ad.SetupLazyLoader(ae,af) local ag={}; for ah,ai in ae:GetChildren()do ag[ai.Name]=ai end setmetatable(af,{ __index=function(ah,ai) local b=ag[ai]; assert(b,string.format('[Library]: Cannot find module %s in %s',ai,ab.Name)) local c,d=pcall(ac,b) assert(c,string.format('[Library]: Failed to Initalize Module %s in %s: %s',ai,ab.Name,tostring(d))) assert(typeof(d)=='function',string.format('[Library]: Module %s is NOT a Function',ai)) local e,f=pcall(d,ad) assert(e,string.format('[Library]: Failed to Load Module %s in %s: %s',ai,ab.Name,tostring(f))) rawset(ah,ai,f) return f end, }) end ad.SetupLazyLoader(ab,ad) return ad end)()end,function()local aa, ab, ac=a(3)return(function(...)return function(ad) local ae={}; ad.SetupLazyLoader(ab,ae) return ae end end)()end,function()local aa, ab, ac=a(4)return(function(...)return function(ad) local ae={}; ad.SetupLazyLoader(ab,ae) return ae end end)()end,function()a(5)return(function(...)return function(aa) local ab=game:GetService"MarketplaceService" local ac=aa.Libraries.General.Cache local ad=ac.Get"GameInfoCache":SetKeyExpiry(180) return function(ae) if ad[tostring(ae)]then return ad[tostring(ae)] end local af,ag=pcall(ab.GetProductInfo,ab,ae,Enum.InfoType.Asset) if af then ad[tostring(ae)]=ag return ag end return nil end end end)()end,function()a(6)return(function(...)return function(aa) return function(ab) local ac=0; for ad,ae in ab do ac=ac+1 end return ac end end end)()end,function()a(7)return(function(...)return function(aa) local ab=aa.Libraries.General.Cache local ac=ab.Get'ScriptCache' return function() local ad=ac.InitTime if(not ad)then return 0 end return DateTime.now().UnixTimestamp-ad end end end)()end,function()a(8)return(function(...)return function(aa) return function(ab) local ac=(ab-ab%60)/60 ab=ab-ac*60 local ad=(ac-ac%60)/60 ac=ac-ad*60 return string.format("%02i",ad)..":"..string.format("%02i",ac)..":"..string.format("%02i",ab) end end end)()end,function()a(9)return(function(...)return function(aa) local ab; local ac=game:GetService"VirtualUser" local ad=Random.new() local ae=game.Players.LocalPlayer return function(af) if af==false then if ab then ab:Disconnect()end; return true end if ab then return true end ab=ae.Idled:Connect(function() ac:Button2Down(Vector2.new(0,0),workspace.CurrentCamera.CFrame) task.wait(ad:NextNumber(0,1)) ac:Button2Up(Vector2.new(0,0),workspace.CurrentCamera.CFrame) end) end end end)()end,function()a(10)return(function(...)return function(aa) return function(ab) local ac=ab.Character if(not ac)then return false end local ad=ac.PrimaryPart if(not ad)then return false end local ae=ac:FindFirstChild"Humanoid" if(not ae)or(ae.Health<=0)then return false end return true end end end)()end,function()a(11)return(function(...)return function(aa) local ab=game.Players.LocalPlayer return function(ac) local ad=ab.Character; if(not ad)or(not ad.HumanoidRootPart)then return end ad.HumanoidRootPart.Anchored=ac end end end)()end,function()a(12)return(function(...)return function(aa) return function(ab,ac,ad,ae) local af=ac or 3 local ag=ad or 1 local ah=ae or{} local ai=0; while ai<af do local b,e=pcall(ab,unpack(ah)) if b and e then return true end ai=ai+ag;task.wait(ag) end return false end end end)()end,function()a(13)return(function(...)return function(aa) local ab={} return function(ac) local ad=tostring(ac); if ab[ad]then return ab[ad]end local ae=ad:reverse():gsub("%d%d%d","%1,"):reverse():gsub("^,",""); ab[ad]=ae return ae end end end)()end,function()a(14)return(function(...)return function(aa) return(syn and syn.request)or(http and http.request)or request or function()return end end end)()end,function()a(15)return(function(...) return function(aa) local ab=aa.Functions.General.HttpRequest local ac=game:GetService"HttpService" return function(ad,ae) if ae then setclipboard("https://www.discord.gg/"..ad) end if(not ab)then return false end ab{ Url="http://127.0.0.1:6463/rpc?v=1", Method="POST", Headers={ ["Content-Type"]="application/json",Origin= "https://discord.com" }, Body=ac:JSONEncode{ cmd="INVITE_BROWSER", args={ code=ad }, nonce=ac:GenerateGUID(false) } } return true end end end)()end,function()a(16)return(function(...)return function(aa) local ab=getfenv(0); return function(ac,ad,...) for ae,af in ac do if(not ab[af])then return false end end return pcall(ad,...) end end end)()end,function()a(17)return(function(...)return function(aa) local ab=aa.Libraries.General.Services local ac=ab.Players local ad=ac.LocalPlayer local ae=ab.Workspace return function(af) local ag=ad.Character; if(not ag)then return false end local ah=(af.Position-workspace.CurrentCamera.CFrame.Position).Unit; local ai=RaycastParams.new(); ai:AddToFilter(ad.Character) ai.FilterType=Enum.RaycastFilterType.Exclude local b=ae:Raycast(workspace.CurrentCamera.CFrame.Position,ah*1000,ai); print(b.Instance) print(b.Position) if b and b.Instance==af then return true end return false end end end)()end,function()local aa, ab, ac=a(18)return(function(...)return function(ad) local ae={}; ad.SetupLazyLoader(ab,ae) return ae end end)()end,function()a(19)return(function(...)return function(aa) return function(ab) local ac=Drawing.new'Text'; ac.Text=ab.Text or'Text' ac.Color=ab.TextColor or Color3.new(1,1,1) if ab.Stroke then ac.OutlineColor=Color3.new() ac.Outline=true end ac.Center=true ac.Position=Vector2.new(0,0); return ac end end end)()end,function()a(20)return(function(...)return function(aa) return function(ab) local ac=Instance.new"BoxHandleAdornment"; for ad,ae in ab do ac[ad]=ae end return ac end end end)()end,function()a(21)return(function(...)return function(aa) return function(ab) local ac=Instance.new"Highlight"; for ad,ae in ab do ac[ad]=ae end return ac end end end)()end,function()a(22)return(function(...)return function(aa) local ab=aa.Libraries.General.Services local ac=ab.Players local ad=ac.LocalPlayer; local ae=aa.Functions.Game.GetEnemies return function() local af,ag=(math.huge) for ah,ai in ae()do local b=ai.PrimaryPart; if(not b)then continue end local e=ai:FindFirstChild"Humanoid"; if(not e)or(e.Health<=0)then continue end local f=ad:DistanceFromCharacter(b.Position) if f<af then af=f ag=ai end end return ag,af end end end)()end,function()a(23)return(function(...)return function(aa) local ab=aa.Libraries.General.Services local ac=ab.UserInputService local ad= ab.CollectionService local ae=ab.Players local af=aa.Functions.General.IsPartVisible local ag=aa.Functions.Game.GetEnemies local ah=ae.LocalPlayer return function(ai) local b,e=ai or math.huge; for f,g in ag()do if(not g.PrimaryPart)or(not g.Head)then continue end local i=g:FindFirstChildWhichIsA'Humanoid'; if(not i)or(i.Health<=0)then continue end local j=ah:DistanceFromCharacter(g.PrimaryPart.Position); if j>600 then continue end local l,n=workspace.CurrentCamera:WorldToViewportPoint(g.Head.Position); if(not n)then continue end if(not af(g.Head))then continue end local o=(ac:GetMouseLocation()-Vector2.new(l.X,l.Y)).Magnitude; if b>o then b=o e=g end end return e,b end end end)()end,function()a(24)return(function(...)return function(aa) local ab=aa.Libraries.General.Services local ac=ab.CollectionService return function() return ac:GetTagged'Enemy' end end end)()end,function()local aa, ab, ac=a(25)return(function(...)return function(ad) local ae={}; ad.SetupLazyLoader(ab,ae) return ae end end)()end,function()local aa, ab, ac=a(26)return(function(...)return function(ad) local ae={}; ad.SetupLazyLoader(ab,ae) return ae end end)()end,function()a(27)return(function(...)return function(aa) local ab="Non-promise value passed into %s at index %s" local ac="Please pass a list of promises to %s" local ad="Please pass a handler function to %s!" local ae={__mode="k"} local function af(ag) if type(ag)=="function"then return true end if type(ag)=="table"then local ah=getmetatable(ag) if ah and type(rawget(ah,"__call"))=="function"then return true end end return false end local function ag(ah,ai) local b={} for e,f in ipairs(ai)do b[f]=f end return setmetatable(b,{ __index=function(e,f) error(string.format("%s is not in %s!",f,ah),2) end, __newindex=function() error(string.format("Creating new members in %s is not allowed!",ah),2) end, }) end local ah do ah={ Kind=ag("Promise.Error.Kind",{ "ExecutionError", "AlreadyCancelled", "NotResolvedInTime", "TimedOut", }), } ah.__index=ah function ah.new(ai,b) ai=ai or{} return setmetatable({ error=tostring(ai.error)or"[This error has no error text.]", trace=ai.trace, context=ai.context, kind=ai.kind, parent=b, createdTick=os.clock(), createdTrace=debug.traceback(), },ah) end function ah.is(ai) if type(ai)=="table"then local b=getmetatable(ai) if type(b)=="table"then return rawget(ai,"error")~=nil and type(rawget(b,"extend"))=="function" end end return false end function ah.isKind(ai,b) assert(b~=nil,"Argument #2 to Promise.Error.isKind must not be nil") return ah.is(ai)and ai.kind==b end function ah.extend(ai,b) b=b or{} b.kind=b.kind or ai.kind return ah.new(b,ai) end function ah.getErrorChain(ai) local b={ai} while b[#b].parent do table.insert(b,b[#b].parent) end return b end function ah.__tostring(ai) local b={ string.format("-- Promise.Error(%s) --",ai.kind or"?"), } for e,f in ipairs(ai:getErrorChain())do table.insert( b, table.concat({ f.trace or f.error, f.context, },"\n") ) end return table.concat(b,"\n") end end local function ai(...) return select("#",...),{...} end local function b(e,...) return e,select("#",...),{...} end local function e(f) assert(f~=nil,"traceback is nil") return function(g) if type(g)=="table"then return g end return ah.new{ error=g, kind=ah.Kind.ExecutionError, trace=debug.traceback(tostring(g),2), context="Promise created at:\n\n"..f, } end end local function f(g,i,...) return b(xpcall(i,e(g),...)) end local function g(i,j,l,n) return function(...) local o,r,s=f(i,j,...) if o then l(unpack(s,1,r)) else n(s[1]) end end end local function i(j) return next(j)==nil end local j={ Error=ah, Status=ag("Promise.Status",{"Started","Resolved","Rejected","Cancelled"}), _getTime=os.clock, _timeEvent=game:GetService"RunService".Heartbeat, _unhandledRejectionCallbacks={}, } j.prototype={} j.__index=j.prototype function j._new(l,n,o) if o~=nil and not j.is(o)then error("Argument #2 to Promise.new must be a promise or nil",2) end local r={ _thread=nil, _source=l, _status=j.Status.Started, _values=nil, _valuesLength=-1, _unhandledRejection=true, _queuedResolve={}, _queuedReject={}, _queuedFinally={}, _cancellationHook=nil, _parent=o, _consumers=setmetatable({},ae), } if o and o._status==j.Status.Started then o._consumers[r]=true end setmetatable(r,j) local function s(...) r:_resolve(...) end local function u(...) r:_reject(...) end local function v(w) if w then if r._status==j.Status.Cancelled then w() else r._cancellationHook=w end end return r._status==j.Status.Cancelled end r._thread=coroutine.create(function()local w, x, z=f(r._source,n,s,u,v) if not w then u(z[1]) end end) task.spawn(r._thread) return r end function j.new(l) return j._new(debug.traceback(nil,2),l) end function j.__tostring(l) return string.format("Promise(%s)",l._status) end function j.defer(l) local n=debug.traceback(nil,2) local o o=j._new(n,function(r,s,u) local v v=j._timeEvent:Connect(function() v:Disconnect()local w, x, z=f(n,l,r,s,u) if not w then s(z[1]) end end) end) return o end j.async=j.defer function j.resolve(...) local l,n=ai(...) return j._new(debug.traceback(nil,2),function(o) o(unpack(n,1,l)) end) end function j.reject(...) local l,n=ai(...) return j._new(debug.traceback(nil,2),function(o,r) r(unpack(n,1,l)) end) end function j._try(l,n,...) local o,r=ai(...) return j._new(l,function(s) s(n(unpack(r,1,o))) end) end function j.try(l,...) return j._try(debug.traceback(nil,2),l,...) end function j._all(l,n,o) if type(n)~="table"then error(string.format(ac,"Promise.all"),3) end for r,s in pairs(n)do if not j.is(s)then error(string.format(ab,"Promise.all",tostring(r)),3) end end if#n==0 or o==0 then return j.resolve{} end return j._new(l,function(r,s,u) local v={} local w={} local x=0 local z=0 local A=false local function B() for C,D in ipairs(w)do D:cancel() end end local function C(D,...) if A then return end x=x+1 if o==nil then v[D]=... else v[x]=... end if x>=(o or#n)then A=true r(v) B() end end u(B) for D,E in ipairs(n)do w[D]=E:andThen(function(...) C(D,...) end,function(...) z=z+1 if o==nil or#n-z<o then B() A=true s(...) end end) end if A then B() end end) end function j.all(l) return j._all(debug.traceback(nil,2),l) end function j.fold(l,n,o) assert(type(l)=="table","Bad argument #1 to Promise.fold: must be a table") assert(af(n),"Bad argument #2 to Promise.fold: must be a function") local r=j.resolve(o) return j.each(l,function(s,u) r=r:andThen(function(v) return n(v,s,u) end) end):andThen(function() return r end) end function j.some(l,n) assert(type(n)=="number","Bad argument #2 to Promise.some: must be a number") return j._all(debug.traceback(nil,2),l,n) end function j.any(l) return j._all(debug.traceback(nil,2),l,1):andThen(function(n) return n[1] end) end function j.allSettled(l) if type(l)~="table"then error(string.format(ac,"Promise.allSettled"),2) end for n,o in pairs(l)do if not j.is(o)then error(string.format(ab,"Promise.allSettled",tostring(n)),2) end end if#l==0 then return j.resolve{} end return j._new(debug.traceback(nil,2),function(n,o,r) local s={} local u={} local v=0 local function w(x,...) v=v+1 s[x]=... if v>=#l then n(s) end end r(function() for x,z in ipairs(u)do z:cancel() end end) for x,z in ipairs(l)do u[x]=z:finally(function(...) w(x,...) end) end end) end function j.race(l) assert(type(l)=="table",string.format(ac,"Promise.race")) for n,o in pairs(l)do assert(j.is(o),string.format(ab,"Promise.race",tostring(n))) end return j._new(debug.traceback(nil,2),function(n,o,r) local s={} local u=false local function v() for w,x in ipairs(s)do x:cancel() end end local function w(x) return function(...) v() u=true return x(...) end end if r(w(o))then return end for x,z in ipairs(l)do s[x]=z:andThen(w(n),w(o)) end if u then v() end end) end function j.each(l,n) assert(type(l)=="table",string.format(ac,"Promise.each")) assert(af(n),string.format(ad,"Promise.each")) return j._new(debug.traceback(nil,2),function(o,r,s) local u={} local v={} local w=false local function x() for z,A in ipairs(v)do A:cancel() end end s(function() w=true x() end) local z={} for A,B in ipairs(l)do if j.is(B)then if B:getStatus()==j.Status.Cancelled then x() return r(ah.new{ error="Promise is cancelled", kind=ah.Kind.AlreadyCancelled, context=string.format( "The Promise that was part of the array at index %d passed into Promise.each was already cancelled when Promise.each began.\n\nThat Promise was created at:\n\n%s", A, B._source ), }) elseif B:getStatus()==j.Status.Rejected then x() return r(select(2,B:await())) end local C=B:andThen(function(...) return... end) table.insert(v,C) z[A]=C else z[A]=B end end for A,B in ipairs(z)do if j.is(B)then local C C,B=B:await() if not C then x() return r(B) end end if w then return end local C=j.resolve(n(B,A)) table.insert(v,C) local D,E=C:await() if not D then x() return r(E) end u[A]=E end o(u) end) end function j.is(l) if type(l)~="table"then return false end local n=getmetatable(l) if n==j then return true elseif n==nil then return af(l.andThen) elseif type(n)=="table" and type(rawget(n,"__index"))=="table" and af(rawget(rawget(n,"__index"),"andThen")) then return true end return false end function j.promisify(l) return function(...) return j._try(debug.traceback(nil,2),l,...) end end do local l local n function j.delay(o) assert(type(o)=="number","Bad argument #1 to Promise.delay, must be a number.") if not(o>=1.6666666666666665E-2)or o==math.huge then o=1.6666666666666665E-2 end return j._new(debug.traceback(nil,2),function(r,s,u) local v=j._getTime() local w=v+o local x={ resolve=r, startTime=v, endTime=w, } if n==nil then l=x n=j._timeEvent:Connect(function() local z=j._getTime() while l~=nil and l.endTime<z do local A=l l=A.next if l==nil then n:Disconnect() n=nil else l.previous=nil end A.resolve(j._getTime()-A.startTime) end end) else if l.endTime<w then local z=l local A=z.next while A~=nil and A.endTime<w do z=A A=z.next end z.next=x x.previous=z if A~=nil then x.next=A A.previous=x end else x.next=l l.previous=x l=x end end u(function() local z=x.next if l==x then if z==nil then n:Disconnect() n=nil else z.previous=nil end l=z else local A=x.previous A.next=z if z~=nil then z.previous=A end end end) end) end end function j.prototype.timeout(l,n,o) local r=debug.traceback(nil,2) return j.race{ j.delay(n):andThen(function() return j.reject(o==nil and ah.new{ kind=ah.Kind.TimedOut, error="Timed out", context=string.format( "Timeout of %d seconds exceeded.\n:timeout() called at:\n\n%s", n, r ), }or o) end), l, } end function j.prototype.getStatus(l) return l._status end function j.prototype._andThen(l,n,o,r) l._unhandledRejection=false if l._status==j.Status.Cancelled then local s=j.new(function()end) s:cancel() return s end return j._new(n,function(s,u,v) local w=s if o then w=g(n,o,s,u) end local x=u if r then x=g(n,r,s,u) end if l._status==j.Status.Started then table.insert(l._queuedResolve,w) table.insert(l._queuedReject,x) v(function() if l._status==j.Status.Started then table.remove(l._queuedResolve,table.find(l._queuedResolve,w)) table.remove(l._queuedReject,table.find(l._queuedReject,x)) end end) elseif l._status==j.Status.Resolved then w(unpack(l._values,1,l._valuesLength)) elseif l._status==j.Status.Rejected then x(unpack(l._values,1,l._valuesLength)) end end,l) end function j.prototype.andThen(l,n,o) assert(n==nil or af(n),string.format(ad,"Promise:andThen")) assert(o==nil or af(o),string.format(ad,"Promise:andThen")) return l:_andThen(debug.traceback(nil,2),n,o) end function j.prototype.catch(l,n) assert(n==nil or af(n),string.format(ad,"Promise:catch")) return l:_andThen(debug.traceback(nil,2),nil,n) end function j.prototype.tap(l,n) assert(af(n),string.format(ad,"Promise:tap")) return l:_andThen(debug.traceback(nil,2),function(...) local o=n(...) if j.is(o)then local r,s=ai(...) return o:andThen(function() return unpack(s,1,r) end) end return... end) end function j.prototype.andThenCall(l,n,...) assert(af(n),string.format(ad,"Promise:andThenCall")) local o,r=ai(...) return l:_andThen(debug.traceback(nil,2),function() return n(unpack(r,1,o)) end) end function j.prototype.andThenReturn(l,...) local n,o=ai(...) return l:_andThen(debug.traceback(nil,2),function() return unpack(o,1,n) end) end function j.prototype.cancel(l) if l._status~=j.Status.Started then return end l._status=j.Status.Cancelled if l._cancellationHook then l._cancellationHook() end coroutine.close(l._thread) if l._parent then l._parent:_consumerCancelled(l) end for n in pairs(l._consumers)do n:cancel() end l:_finalize() end function j.prototype._consumerCancelled(l,n) if l._status~=j.Status.Started then return end l._consumers[n]=nil if next(l._consumers)==nil then l:cancel() end end function j.prototype._finally(l,n,o) l._unhandledRejection=false local r=j._new(n,function(r,s,u) local v u(function() l:_consumerCancelled(l) if v then v:cancel() end end) local w=r if o then w=function(...) local x=o(...) if j.is(x)then v=x x :finally(function(z) if z~=j.Status.Rejected then r(l) end end) :catch(function(...) s(...) end) else r(l) end end end if l._status==j.Status.Started then table.insert(l._queuedFinally,w) else w(l._status) end end) return r end function j.prototype.finally(l,n) assert(n==nil or af(n),string.format(ad,"Promise:finally")) return l:_finally(debug.traceback(nil,2),n) end function j.prototype.finallyCall(l,n,...) assert(af(n),string.format(ad,"Promise:finallyCall")) local o,r=ai(...) return l:_finally(debug.traceback(nil,2),function() return n(unpack(r,1,o)) end) end function j.prototype.finallyReturn(l,...) local n,o=ai(...) return l:_finally(debug.traceback(nil,2),function() return unpack(o,1,n) end) end function j.prototype.awaitStatus(l) l._unhandledRejection=false if l._status==j.Status.Started then local n=coroutine.running() l :finally(function() task.spawn(n) end) :catch( function()end ) coroutine.yield() end if l._status==j.Status.Resolved then return l._status,unpack(l._values,1,l._valuesLength) elseif l._status==j.Status.Rejected then return l._status,unpack(l._values,1,l._valuesLength) end return l._status end local function l(n,...) return n==j.Status.Resolved,... end function j.prototype.await(n) return l(n:awaitStatus()) end local function n(o,...) if o~=j.Status.Resolved then error((...)==nil and"Expected Promise rejected with no value."or(...),3) end return... end function j.prototype.expect(o) return n(o:awaitStatus()) end j.prototype.awaitValue=j.prototype.expect function j.prototype._unwrap(o) if o._status==j.Status.Started then error("Promise has not resolved or rejected.",2) end local r=o._status==j.Status.Resolved return r,unpack(o._values,1,o._valuesLength) end function j.prototype._resolve(o,...) if o._status~=j.Status.Started then if j.is((...))then (...):_consumerCancelled(o) end return end if j.is((...))then if select("#",...)>1 then local r=string.format([[When returning a Promise from andThen, extra arguments are discarded! See:%s]], o._source ) warn(r) end local r=... local s=r:andThen(function(...) o:_resolve(...) end,function(...) local s=r._values[1] if r._error then s=ah.new{ error=r._error, kind=ah.Kind.ExecutionError, context="[No stack trace available as this Promise originated from an older version of the Promise library (< v2)]", }end if ah.isKind(s,ah.Kind.ExecutionError)then return o:_reject(s:extend{ error="This Promise was chained to a Promise that errored.", trace="", context=string.format( "The Promise at:\n\n%s\n...Rejected because it was chained to the following Promise, which encountered an error:\n", o._source ), }) end o:_reject(...) end) if s._status==j.Status.Cancelled then o:cancel() elseif s._status==j.Status.Started then o._parent=s s._consumers[o]=true end return end o._status=j.Status.Resolved o._valuesLength,o._values=ai(...) for r,s in ipairs(o._queuedResolve)do coroutine.wrap(s)(...) end o:_finalize() end function j.prototype._reject(o,...) if o._status~=j.Status.Started then return end o._status=j.Status.Rejected o._valuesLength,o._values=ai(...) if not i(o._queuedReject)then for r,s in ipairs(o._queuedReject)do coroutine.wrap(s)(...) end else local r=tostring((...)) coroutine.wrap(function() j._timeEvent:Wait() if not o._unhandledRejection then return end local s=string.format("Unhandled Promise rejection:\n\n%s\n\n%s",r,o._source) for u,v in ipairs(j._unhandledRejectionCallbacks)do task.spawn(v,o,unpack(o._values,1,o._valuesLength)) end if j.TEST then return end warn(s) end)() end o:_finalize() end function j.prototype._finalize(o) for r,s in ipairs(o._queuedFinally)do coroutine.wrap(s)(o._status) end o._queuedFinally=nil o._queuedReject=nil o._queuedResolve=nil if not j.TEST then o._parent=nil o._consumers=nil end task.defer(coroutine.close,o._thread) end function j.prototype.now(o,r) local s=debug.traceback(nil,2) if o._status==j.Status.Resolved then return o:_andThen(s,function(...) return... end) else return j.reject(r==nil and ah.new{ kind=ah.Kind.NotResolvedInTime, error="This Promise was not resolved in time for :now()", context=":now() was called at:\n\n"..s, }or r) end end function j.retry(o,r,...) assert(af(o),"Parameter #1 to Promise.retry must be a function") assert(type(r)=="number","Parameter #2 to Promise.retry must be a number") local s,u={...},select("#",...) return j.resolve(o(...)):catch(function(...) if r>0 then return j.retry(o,r-1,unpack(s,1,u)) else return j.reject(...) end end) end function j.retryWithDelay(o,r,s,...) assert(af(o),"Parameter #1 to Promise.retry must be a function") assert(type(r)=="number","Parameter #2 (times) to Promise.retry must be a number") assert(type(s)=="number","Parameter #3 (seconds) to Promise.retry must be a number") local u,v={...},select("#",...) return j.resolve(o(...)):catch(function(...) if r>0 then j.delay(s):await() return j.retryWithDelay(o,r-1,s,unpack(u,1,v)) else return j.reject(...) end end) end function j.fromEvent(o,r) r=r or function() return true end return j._new(debug.traceback(nil,2),function(s,u,v) local w local x=false local function z() w:Disconnect() w=nil end w=o:Connect(function(...) local A=r(...) if A==true then s(...) if w then z() else x=true end elseif type(A)~="boolean"then error"Promise.fromEvent predicate should always return a boolean" end end) if x and w then return z() end v(z) end) end function j.onUnhandledRejection(o) table.insert(j._unhandledRejectionCallbacks,o) return function() local r=table.find(j._unhandledRejectionCallbacks,o) if r then table.remove(j._unhandledRejectionCallbacks,r) end end end return j end end)()end,function()a(28)return(function(...)return function(aa) local ab local function ac(ad,...) local ae=ab ab=nil ad(...) ab=ae end local function ad(...) ac(...) while true do ac(coroutine.yield()) end end local ae={} ae.__index=ae function ae.Disconnect(af) if not af.Connected then return end af.Connected=false if af._signal._handlerListHead==af then af._signal._handlerListHead=af._next else local ag=af._signal._handlerListHead while ag and ag._next~=af do ag=ag._next end if ag then ag._next=af._next end end end ae.Destroy=ae.Disconnect setmetatable(ae,{ __index=function(af,ag) error(("Attempt to get Connection::%s (not a valid member)"):format(tostring(ag)),2) end, __newindex=function(af,ag,ah) error(("Attempt to set Connection::%s (not a valid member)"):format(tostring(ag)),2) end, }) local ag={} ag.__index=ag function ag.new() return setmetatable({_handlerListHead=false,_proxyHandler=nil,_yieldedThreads=nil},ag) end function ag.Wrap(ah) assert(typeof(ah)=="RBXScriptSignal","Argument #1 to Signal.Wrap must be a RBXScriptSignal; got "..typeof(ah)) local ai=ag.new() ai._proxyHandler=ah:Connect(function(...)ai:Fire(...)end) return ai end function ag.Is(ah) return type(ah)=="table"and getmetatable(ah)==ag end function ag.Connect(ah,ai) local b=setmetatable({Connected=true,_signal=ah,_fn=ai,_next=false},ae) if ah._handlerListHead then b._next=ah._handlerListHead ah._handlerListHead=b else ah._handlerListHead=b end return b end function ag.ConnectOnce(ah,ai)return ah:Once(ai)end function ag.Once(ah,ai) local b local e=false b=ah:Connect(function(...) if e then return end e=true b:Disconnect() ai(...) end) return b end function ag.GetConnections(ah) local ai={} local b=ah._handlerListHead while b do table.insert(ai,b) b=b._next end return ai end function ag.DisconnectAll(ah) local ai=ah._handlerListHead while ai do ai.Connected=false ai=ai._next end ah._handlerListHead=false local b=rawget(ah,"_yieldedThreads") if b then for e in b do if coroutine.status(e)=="suspended"then warn(debug.traceback(e,"signal disconnected; yielded thread cancelled",2)) task.cancel(e) end end table.clear(ah._yieldedThreads) end end function ag.Fire(ah,...) local ai=ah._handlerListHead while ai do if ai.Connected then if not ab then ab=coroutine.create(ad) end task.spawn(ab,ai._fn,...) end ai=ai._next end end function ag.FireDeferred(ah,...) local ai=ah._handlerListHead while ai do local b=ai task.defer(function(...) if b.Connected then b._fn(...)end end,...) ai=ai._next end end function ag.Wait(ah) local ai=rawget(ah,"_yieldedThreads") if not ai then ai={} rawset(ah,"_yieldedThreads",ai) end local b=coroutine.running() ai[b]=true ah:Once(function(...) ai[b]=nil task.spawn(b,...) end) return coroutine.yield() end function ag.Destroy(ah) ah:DisconnectAll() local ai=rawget(ah,"_proxyHandler") if ai then ai:Disconnect()end end setmetatable(ag,{ __index=function(ah,ai) error(("Attempt to get Signal::%s (not a valid member)"):format(tostring(ai)),2) end, __newindex=function(ah,ai,b) error(("Attempt to set Signal::%s (not a valid member)"):format(tostring(ai)),2) end, }) return table.freeze{new=ag.new,Wrap=ag.Wrap,Is=ag.Is} end end)()end,function()local aa, ab, ac=a(29)return(function(...)return function(ad) local ae=game:GetService"HttpService" local ag=ac(ab.Metatable) local ai={can_spawn=true}; local b={} local e=function(e,f) local g=ae:GenerateGUID(false); local i={} i.running=false i.func=ai.can_spawn and f or function()end i.index=e i.creation=DateTime.now().UnixTimestamp i.connections={} i.cleanup={} b[g]=setmetatable(i,{ __index=ag, __tostring=function() return string.format('Thread(%s)', tostring(i.running and"Running"or"Stopped")) end, }) return i end local f=function() for f,g in b do g:Terminate() b[f]=nil end end local g=function(g) for i,j in b do if j.index~=g then continue end j:Terminate() b[i]=nil end end local i=function(i,j) ai[i]=j end return table.freeze{ New=e, TerminateAll=f, TerminateById=g, SetOption=i } end end)()end,function()a(30)return(function(...)local aa={} aa.__index=aa function aa.Terminate(ab) pcall(task.cancel,ab.func) for ac,ad in pairs(ab.connections)do if typeof(ad)=='RBXScriptConnection'then pcall(ad.Disconnect,ad) end ab.connections[ac]=nil end for ac,ad in pairs(ab.cleanup)do if typeof(ad)=='function'then pcall(task.spawn,ad) end ab.cleanup[ac]=nil end ab.running=false end function aa.Start(ab,...) local ac,ad=pcall(task.spawn,ab.func,ab,...) if(not ac)then warn(string.format('Failed to start Thread %s (%s)',ab.index,tostring(ad))) end ab.func=ad ab.running=true return ab end function aa.AddConnection(ab,ac) table.insert(ab.connections,ac) return ab end function aa.AddCleanupFunction(ab,ac) table.insert(ab.cleanup,ac) return ab end function aa.GetAge(ab) return DateTime.now().UnixTimestamp-ab.creation end return aa end)()end,function()a(31)return(function(...)return function(aa) local ab=game:GetService"RunService" local ac=newproxy() local ad=newproxy() local ae=table.freeze{"Destroy","Disconnect","destroy","disconnect"} local function ag(ai,b) local e=typeof(ai) if e=="function"then return ac elseif e=="thread"then return ad end if b then return b end if e=="Instance"then return"Destroy" elseif e=="RBXScriptConnection"then return"Disconnect" elseif e=="table"then for f,g in ae do if typeof(ai[g])=="function"then return g end end end error(string.format('failed to get cleanup function for object %s: %s',tostring(e),tostring(ai)),3) end local function ai(b) if typeof(b)~="table" or typeof(b.getStatus)~="function" or typeof(b.finally)~="function" or typeof(b.cancel)~="function" then error("did not receive a promise as an argument",3) end end local b={} b.__index=b function b.new() local e=setmetatable({},b) e._objects={} e._cleaning=false return e end function b.Add(e,f,g) if e._cleaning then error("cannot call trove:Add() while cleaning",2) end local i=ag(f,g) table.insert(e._objects,{f,i}) return f end function b.Clone(e,f) if e._cleaning then error("cannot call trove:Clone() while cleaning",2) end return e:Add(f:Clone()) end function b.Construct(e,f,...) if e._cleaning then error("Cannot call trove:Construct() while cleaning",2) end local g local i=type(f) if i=="table"then g=f.new(...) elseif i=="function"then g=f(...) end return e:Add(g) end function b.Connect(e,f,g) if e._cleaning then error("Cannot call trove:Connect() while cleaning",2) end return e:Add(f:Connect(g)) end function b.BindToRenderStep(e,f,g,i) if e._cleaning then error("cannot call trove:BindToRenderStep() while cleaning",2) end ab:BindToRenderStep(f,g,i) e:Add(function() ab:UnbindFromRenderStep(f) end) end function b.AddPromise(e,f) if e._cleaning then error("cannot call trove:AddPromise() while cleaning",2) end ai(f) if f:getStatus()=="Started"then f:finally(function() if e._cleaning then return end e:_findAndRemoveFromObjects(f,false) end) e:Add(f,"cancel") end return f end function b.Remove(e,f) if e._cleaning then error("cannot call trove:Remove() while cleaning",2) end return e:_findAndRemoveFromObjects(f,true) end function b.Extend(e) if e._cleaning then error("cannot call trove:Extend() while cleaning",2) end return e:Construct(b) end function b.Clean(e) if e._cleaning then return end e._cleaning=true for f,g in e._objects do e:_cleanupObject(g[1],g[2]) end table.clear(e._objects) e._cleaning=false end function b.WrapClean(e) return function() e:Clean() end end function b._findAndRemoveFromObjects(e,f,g) local i=e._objects for j,l in i do if l[1]==f then local n=#i i[j]=i[n] i[n]=nil if g then e:_cleanupObject(l[1],l[2]) end return true end end return false end function b._cleanupObject(e,f,g) if g==ac then task.spawn(f) elseif g==ad then pcall(task.cancel,f) else f[g](f) end end function b.AttachToInstance(e,f) if e._cleaning then error("cannot call trove:AttachToInstance() while cleaning",2) elseif not f:IsDescendantOf(game)then error("instance is not a descendant of the game hierarchy",2) end return e:Connect(f.Destroying,function() e:Destroy() end) end function b.Destroy(e) e:Clean() end return{ new=b.new, } end end)()end,function()a(32)return(function(...) return function(aa) return{ LRM_IsUserPremium=LRM_IsUserPremium or true, LRM_LinkedDiscordID=LRM_LinkedDiscordID or 1132756183229419661, LRM_ScriptName=LRM_ScriptName or"strelizia.cc", LRM_TotalExecutions=LRM_TotalExecutions or 5, LRM_SecondsLeft=LRM_SecondsLeft or 300, LRM_UserNote=LRM_UserNote or"Developer | Premium | Lifetime", LRM_ScriptVersion=LRM_ScriptVersion or"0.0.0.1" } end end)()end,function()a(33)return(function(...)return function(aa) local ab={ Info='🔵', Warn='🟠', Success='🟢', Error='🔴' } local function ac(ad,ae) local ag=os.date"*t" string.format("%s:%s:%s",ag.hour,ag.min,ag.sec) print(string.format("%s | [Library]: %s",ab[ad],ae)) end return table.freeze{Message=ac} end end)()end,function()a(34)return(function(...)return function(aa) local ab=aa.Libraries.General.Cache; local ac=ab.Get'Actions' local function ad(ae,ag) if(typeof(ae)=='table')then for ai,b in ae do ac[b]=ag end else ac[ae]=ag end return true end local function ae(ag) if(typeof(ag)=='table')then for ai,b in ag do if(not ac[b])then continue end return true end return false else return ac[ag] end end return table.freeze{SetActionState=ad,GetActionState=ae} end end)()end,function()a(35)return(function(...)return function(aa) local ab={} local ac={Fluent= 97404758083545,SaveManager= 132828910264093,ThemeManager= 72525158718178; }; local ad=aa.Functions.General.GetTableSize; local ae=aa.Libraries.General.Promise local ag=aa.Libraries.General.InfoLibrary local ai=function() local ai=os.clock() local b={} for e,f in ac do table.insert(b,ae.new(function(g,i) local j,l=pcall(game.GetObjects,game,"rbxassetid://"..f) if j then g(loadstring(l[1].Source)()) if ag.Debug then ag.Message('Success',string.format('Successfully loaded Interface Module %s: %ss Elapsed', tostring(e), tostring(os.clock()-ai))) end else i(tostring(l)) end end):andThen(function(g) ab[e]=g end):catch(function(g) ag.Message('Error',string.format('Failed to load Interface Module %s: %s', tostring(e), tostring(g))) end)) end ae.all(b):await() if aa.Debug then ag.Message('Info',string.format('Took %ss to load Interface Class (%s Modules)', tostring(os.clock()-ai), tostring(ad(ac)))) end return ab end return{ Get=function() if(ad(ac)~=ad(ab))then ai() end return ab end, } end end)()end,function()a(36)return(function(...)return function(aa) local ab=aa.Libraries.General.Cache local ac=ab.Get"TreeUtil"; local ad={Delimiter="/"}; local function ae(ag,ai,b) local e=ac[ag]; if e then return e end local f=string.split(ag,ad.Delimiter); for g,i in f do ai=ai:FindFirstChild(i)or(b and ai:WaitForChild(i,b))or nil; if(not ai)then return nil end end ac[ag]=ai return ai end function ad.SetDelimiter(ag) ad.Delimiter=ag or"/" end function ad.Find(ag,ai,b) local e=ae(ai,ag,b); return e end return ad end end)()end,function()a(37)return(function(...) return function(aa) return setmetatable({},{ __index=function(ab,ac) local ad,ae=pcall(game.GetService,game,ac); if ad then local ag=cloneref(ae) rawset(ab,ac,ag) return ag end return nil end, }) end end)()end,function()a(38)return(function(...)return function(aa) local ab={_cached={}}; ab.__index=ab function ab.Get(ac) if ab._cached[ac]then return ab._cached[ac] else local ad=setmetatable({_settings={}},{ __index=ab, __newindex=function(ad,ae,ag) rawset(ad,ae,ag) local ai=ad._settings.expiry if ai then task.delay(ai,rawset,ad,ae,nil) end end, }) ab._cached[ac]=ad return ad end end function ab.SetKeyExpiry(ac,ad) ac._settings.expiry=tonumber(ad) return ac end function ab.Clear(ac) for ad,ae in pairs(ac)do if ad=='_settings'then continue end ac[ad]=nil end return ac end return ab end end)()end,function()a(39)return(function(...)return function(aa) local ab={}; function ab.Keys(ac) local ad={}; for ae in pairs(ac)do table.insert(ad,ae) end return ad end function ab.Values(ac) local ad={} for ae,ag in pairs(ac)do table.insert(ad,ag) end return ad end function ab.ArrayToSet(ac) local ad={}; for ae in pairs(ac)do ad[ae]=true end return ad end function ab.ReverseKeyValue(ac) local ad={} for ae,ag in pairs(ac)do ad[ag]=ae end return ad end function ab.Reconcile(ac,ad) for ae,ag in pairs(ad)do if ac[ae]then continue end ac[ae]=ag end return ac end return ab end end)()end,function()local aa, ab, ac=a(40)return(function(...)return function(ad) local ae={}; ad.SetupLazyLoader(ab,ae) return ae end end)()end,function()local aa, ab, ac=a(41)return(function(...)return function(ad) local ae={} local ag=game:GetService"ReplicatedStorage" game:GetService"ReplicatedFirst" local ai=ad.Libraries.General.Promise local b=ad.Libraries.General.Tree local e=ad.Functions.General.GetTableSize local f=ad.Libraries.General.InfoLibrary local function g() local i=game.Players.LocalPlayer local j= i.Character local l={ SomePath=b.Find(ag,'Shared/Remotes',1) } return l end local function i(j) local l={} for n,o in j do table.insert(l,ai.new(function(r,s) local u,v=pcall(ac,o); if u then r(v) else s(tostring(v)) end end):andThen(function(r)ae[n]=r end):catch(function(r) f.Message('Error',string.format('Failed to require Game Module %s: %s', tostring(o.Name), tostring(r))) end)) end ai.all(l):await() return ae end local function j() local l=g() if e(l)~=e(ae)then return i(l) end return ae end return table.freeze{ Get=j } end end)()end} local ab={{1,4,{"Init"},{{2,2,{"Library"},{{25,2,{"Libraries"},{{40,2,{"Game"},{{41,2,{"GameModules"}}}},{26,2,{"General"},{{34,2,{"Actions"}},{36,2,{"Tree"}},{32,2,{"LRM_Variables"}},{35,2,{"Interface"}},{38,2,{"Cache"}},{31,2,{"Trove"}},{29,2,{"Threading"},{{30,2,{"Metatable"}}}},{28,2,{"Signal"}},{33,2,{"InfoLibrary"}},{27,2,{"Promise"}},{39,2,{"TableUtils"}},{37,2,{"Services"}}}}}},{3,2,{"Functions"},{{18,2,{"Game"},{{24,2,{"GetEnemies"}},{20,2,{"CreateBoundingBox"}},{22,2,{"GetNearestEnemy"}},{19,2,{"CreateTextEsp"}},{21,2,{"CreateHighlight"}},{23,2,{"GetNearestEnemyToMouse"}}}},{4,2,{"General"},{{9,2,{"AntiAFK"}},{5,2,{"GetGameInfo"}},{6,2,{"GetTableSize"}},{8,2,{"FormatHms"}},{17,2,{"IsPartVisible"}},{13,2,{"CommaNumber"}},{12,2,{"Timeout"}},{16,2,{"AssertFunctions"}},{14,2,{"HttpRequest"}},{10,2,{"IsAlive"}},{15,2,{"PromptDiscordJoin"}},{7,2,{"GetUptime"}},{11,2,{"SetPlayerAnchored"}}}}}}}}}}} local ac local ad="0.4.1" local ae="strelizia.cc" local ag,ai,b,e,f,g,i,j,l,n,o,r,s,u,v= string,task,setmetatable,error,next,table,unpack,coroutine,script,type,require,pcall,tostring,tonumber,_VERSION local w=g.insert local x=g.remove local z=g.freeze or function(z)return z end local A=j.wrap local B=ag.sub local C=ag.match local D=ag.gmatch if v and B(v,1,4)=="Lune"then local E,F=r(o,"@lune/task") if E and F then ai=F end end local E=ai and ai.defer local F=E or function(F,...) A(F)(...) end local G={ [1]="Folder", [2]="ModuleScript", [3]="Script", [4]="LocalScript", [5]="StringValue", } local H={} local I={} local J={} local K={} local L={} local M={} local N={} local O={ GetFullName={{},function(O) local P=O.Name local Q=O.Parent while Q do P=Q.Name.."."..P Q=Q.Parent end return P end}, GetChildren={{},function(O) local P={} for Q in f,N[O]do w(P,Q) end return P end}, GetDescendants={{},function(O) local P={} for Q in f,N[O]do w(P,Q) for R,S in f,Q:GetDescendants()do w(P,S) end end return P end}, FindFirstChild={{"string","boolean?"},function(O,P,Q) local R=N[O] for S in f,R do if S.Name==P then return S end end if Q then for S in f,R do return S:FindFirstChild(P,true) end end end}, FindFirstAncestor={{"string"},function(O,P) local Q=O.Parent while Q do if Q.Name==P then return Q end Q=Q.Parent end end}, WaitForChild={{"string","number?"},function(O,P) return O:FindFirstChild(P) end}, } local P={} for Q,R in f,O do local S=R[1] local T=R[2] local U={} for V,W in f,S do local X,Y=C(W,"^([^%?]+)(%??)") U[V]={X,Y} end P[Q]=function(V,...) if not N[V]then e("Expected ':' not '.' calling member function "..Q,2) end local W={...} for X,Y in f,U do local Z=W[X] local _=n(Z) local aj,ak=Y[1],Y[2] if Z==nil and not ak then e("Argument "..Z.." missing or nil",3) end if aj~="any"and _~=aj and not(_=="nil"and ak)then e("Argument "..X.." expects type \""..aj.."\", got \"".._.."\"",2) end end return T(V,...) end end local function aj(ak,Q,R) local S local T=b({},{__mode="k"}) local function U(V) e(V.." is not a valid (virtual) member of "..ak.." \""..Q.."\"",3) end local function V(W) e("Unable to assign (virtual) property "..W..". Property is read only",3) end local W={} local X={} X.__metatable=false X.__index=function(Y,Z) if Z=="ClassName"then return ak elseif Z=="Name"then return Q elseif Z=="Parent"then return R elseif ak=="StringValue"and Z=="Value"then return S else local _=P[Z] if _ then return _ end end for _ in f,T do if _.Name==Z then return _ end end U(Z) end X.__newindex=function(Y,Z,_) if Z=="ClassName"then V(Z) elseif Z=="Name"then Q=_ elseif Z=="Parent"then if _==W then return end if R~=nil then N[R][W]=nil end R=_ if _~=nil then N[_][W]=true end elseif ak=="StringValue"and Z=="Value"then S=_ else U(Z) end end X.__tostring=function() return Q end b(W,X) N[W]=T if R~=nil then N[R][W]=true end return W end local function ak(Q,R) local S=Q[1] local T=Q[2] local U=Q[3] local V=Q[4] local W=G[T] local X=U and x(U,1)or W local Y=aj(W,X,R) H[S]=Y if U then for Z,_ in f,U do Y[Z]=_ end end if V then for Z,_ in f,V do ak(_,Y) end end return Y end local Q=aj("Folder","["..ae.."]") for R,S in f,ab do ak(S,Q) end for R,S in f,aa do local T=H[R] I[T]=S J[T]=R local U=T.ClassName if U=="LocalScript"or U=="Script"then w(L,T) end end local function R(S) local T=S.ClassName local U=K[S] if U and T=="ModuleScript"then return i(U) end local V=I[S] local function W(X) X=s(X) local Y=S:GetFullName() local Z,_=C(X,"[^:]+:(%d+): (.+)") if not Z or not ac then return Y..":*: "..(_ or X) end Z=u(Z) local al=J[S] local am=ac[al] local an=Z-am+1 if an<0 then an="?" end return Y..":"..an..": ".._ end if T=="LocalScript"or T=="Script"then local al,am=r(V) if not al then e(W(am),0) end else local al={r(V)} local am=x(al,1) if not am then local an=x(al,1) e(W(an),0) end K[S]=al return i(al) end end function a(al) local am=H[al] local function an(S,...) local T={r(S,...)} local U=x(T,1) if not U then e(T[1],3) end return i(T) end local S=z(b({},{ __index=M, __newindex=function(S,T,U) M[T]=U end, __len=function() return#M end, __iter=function() return f,M end, })) local T=z{ version=ad, envname=ae, shared=S, script=l, require=o, } local U=am local function V(W,...) local X=n(W) local Y="Attempted to call require with a non-ModuleScript" local Z="Attempted to call require with self" if X=="table"and N[W]then if W.ClassName~="ModuleScript"then e(Y,2) elseif W==am then e(Z,2) end return R(W) elseif X=="string"and B(W,1,1)~="@"then if#W==0 then e("Attempted to call require with empty string",2) end local _=am if B(W,1,1)=="/"then _=Q elseif B(W,1,2)=="./"then W=B(W,3) end local ao for ap in D(W,"([^/]*)/?")do local aq=ap if ap==".."then aq="Parent" end if aq~=""then local ar=_:FindFirstChild(aq) if not ar then local as=_.Parent if as then ar=as:FindFirstChild(aq) end end if ar then _=ar elseif ap~=ao and ap~="init"and ap~="init.server"and ap~="init.client"then e("Virtual script path \""..W.."\" not found",2) end end ao=ap end if _.ClassName~="ModuleScript"then e(Y,2) elseif _==am then e(Z,2) end return R(_) end return an(o,W,...) end return T,U,V end for al,am in f,L do F(R,am) end
