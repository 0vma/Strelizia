local a={ { ClassName="LocalScript", Closure=function() if(not game:IsLoaded())then game.Loaded:Wait() end if Fluent then Fluent.Destroy()end local a=require(script.Library); a.Debug=true; local b=a.Libraries local c=b.Special local d= c.GameModules local e=b.Generic local f=e.Cache local g=e.LRM_Variables local h= e.Actions local i=e.Interface.Get()local j= e.Tree local k= e.Promise local l= e.Signal local m=e.Threading local n=e.Services local o= e.Trove local p=a.Functions local q=p.Special local r=p.Generic local s=n.Players local t= n.RunService local u=n.Workspace local v= n.ReplicatedStorage local w= n.UserInputService local x= n.GuiService local y=n.CoreGui local z=s.LocalPlayer local A=game.FindFirstChild local B=game.FindFirstChildWhichIsA local C= game.FindFirstAncestor local D= game.IsA local E=f.Get'ScriptCache'; E.InitTime=DateTime.now().UnixTimestamp local F=i.Fluent local G=i.SaveManager local H=i.ThemeManager getgenv().Fluent=F local I=F:CreateWindow{ Title="strelizia.cc", SubTitle="v"..g.LRM_ScriptVersion, TabWidth=120, Size=UDim2.fromOffset(600,480), Resize=true, MinSize=Vector2.new(430,350), Acrylic=false, Theme="Darker", MinimizeKey=Enum.KeyCode.RightControl } local J={ Home=I:CreateTab{ Title="Home", Icon="house" }, Combat=I:CreateTab{ Title="Combat", Icon="swords" }, Visuals=I:CreateTab{ Title="Visuals", Icon="eye" }, Misc=I:CreateTab{ Title="Others", Icon="circle-ellipsis" }, Settings=I:CreateTab{ Title="Settings", Icon="settings" }, } local K={ Home_Information=J.Home:AddSection"↳ Information", Home_Credits=J.Home:AddSection"↳ Credits", Combat_SilentAim=J.Combat:AddSection"↳ Silent Aim", Combat_Ragebot=J.Combat:AddSection"↳ Rage Bot", Visuals_ZombieESP=J.Visuals:AddSection"↳ Zombie Text", Visuals_PowerupESP=J.Visuals:AddSection"↳ Powerup Text", Misc_Movement=J.Misc:AddSection"↳ Movement", Misc_Others=J.Misc:AddSection"↳ Others" } do local L=K.Home_Information:CreateParagraph("ClientUptimeParagraph",{ Title="Client Uptime: nil", TitleAlignment=Enum.TextXAlignment.Center, }); m.New("ClientUptimeParagraph",function(M) while F.Loaded and task.wait(1)do L.Instance.TitleLabel.Text=string.format("Script Uptime: %s",r.FormatHms(r.GetUptime())) end end):Start() local M=K.Home_Information:CreateParagraph("LuaHeapParagraph",{ Title="Lua Heap (Megabytes): nil", TitleAlignment=Enum.TextXAlignment.Center, }); m.New("LuaHeapParagraph",function(N) while F.Loaded and task.wait(1)do M.Instance.TitleLabel.Text=string.format('Lua Heap: %sMB', tostring(r.CommaNumber(math.ceil(gcinfo()/1000)))) end end):Start() K.Home_Information:CreateButton{ Title="Join Discord", Description="prompts discord invite if the user is on pc, copies to clipboard otherwise", Callback=function() r.PromptDiscordJoin('Vf4Wu3Cft7',true) F:Notify{ Title="Discord Prompted/Copied", Content="discord invite has been prompted/copied to your clipboard!", Duration=2 } end } K.Home_Credits:CreateParagraph("Credits",{ Title="vma, kalas, pryxo, felix", TitleAlignment=Enum.TextXAlignment.Center, }); end do r.AssertFunctions({"getrawmetatable","hookmetamethod"},function() local L=K.Combat_SilentAim:CreateSlider("SilentAimFOV",{Title="Field of View",Description="(0 = infinite)",Default=90,Min=0,Max=360,Rounding=0}) local M=K.Combat_SilentAim:CreateToggle("ShowSilentAimFOV",{Title="Show Field of View",Default=false,Description="lets you see the fov circle on the screen"}) M:OnChanged(function(N) if not N then m.TerminateById'ShowSilentAimFOV'; return end m.New('ShowSilentAimFOV',function(O) O:AddObject(r.SmartDraw('Circle',{ Radius=L.Value, Color=Color3.fromRGB(255,255,255), Filled=false, NumSides=64, Visible=false, Transparency=1, Thickness=2 },function(P,Q)local R, S=r.GetScreenSize() local T=r.GetMousePosition() P.Visible=M.Value P.Radius=L.Value P.Position=Vector2.new(T.X,T.Y+S.Y) end)) end):Start() end) local N=K.Combat_SilentAim:CreateToggle("SilentAimToggle",{Title="Silent Aim",Default=false,Description="determines if silent aim is on or off"}) local O O=hookmetamethod(game,"__namecall",newcclosure(function(P,...) local Q=getnamecallmethod(); if N.Value and Q=='FireServer'and(not F.Options.AutoFireToggle.Value)then local R=q.GetWeapon(); if P==A(R,'Event')then local S=L.Value local T={...} local U=q.GetClosestEnemyToMouse((S==0 and math.huge)or S); if U then T[1]=U.Head.Position end setnamecallmethod'FireServer' return O(P,unpack(T)) end end return O(P,...) end)) end,function(L) K.Combat_SilentAim:CreateParagraph("AssetFuncSilentAim",{ Title="Unsupported Executor", TitleAlignment=Enum.TextXAlignment.Center, Content=string.format('your executor lacks features required for this feature: %s', tostring(table.concat(L,", "))), ContentAlignment=Enum.TextXAlignment.Center }); end) K.Combat_Ragebot:CreateParagraph("RagebotNote",{ Title="Ragebot Note", TitleAlignment=Enum.TextXAlignment.Center, Content="Ragebot is obvious and you can get banned while using it, use it WITH CAUTION!\nSilent aim settings don't affect ragebot", ContentAlignment=Enum.TextXAlignment.Center }); local L=K.Combat_Ragebot:CreateToggle("AutoFireToggle",{Title="Auto Fire",Default=false,Description="automatically fires towards enemies while not consuming any ammo and ignoring all debounce restrictions"}) local M=K.Combat_Ragebot:CreateToggle("RagebotTeleport",{Title="Teleport to Zombies",Description="determines if the script will teleport around zombies to shoot them (doesnt work without auto fire)",Default=false}) local N=K.Combat_Ragebot:CreateSlider("TeleportDistance",{Title="Teleport Distance",Description="in studs",Default=15,Min=1,Max=30,Rounding=0}) L:OnChanged(function(O) if not O then m.TerminateById'AutoFireToggle' return end m.New('AutoFireToggle',function(P) while F.Loaded and task.wait()do if(not r.IsAlive(z))then continue end local Q=z.Character; local R=Q.PrimaryPart local S=R.Position; if S.Y<=-250 then R.CFrame=CFrame.new(S.X,500,S.Z) end local T=q.GetEnemies() if(not T)or(#T<1)then continue end for U,V in T do r.HaltLatency(400,150) local W=A(V,'HumanoidRootPart'); if(not W)then continue end local X=q.GetWeapon(); if(not X)or(not X.Parent)then X=q.GetWeapon()continue end local Y=A(V,'Appearance'); Y=(Y and Y:GetChildren())or{} if M.Value then local Z=N.Value local _, aa, ab=q.ResolveTeleportDistance(V,Z,15,{Ignore=Y,ParentMatching=true}); if(not _)then continue end R.CFrame=CFrame.lookAt(aa,W.Position); else if not r.IsPartVisible(W,X.Muzzle.Position,{Ignore=Y,ParentMatching=true})then continue end end X.Event:FireServer(W.Position); end end end):Start() end) end do r.AssertFunctions({'drawing'},function() local aa={}; local ab=K.Visuals_ZombieESP:CreateToggle("ZombieTextToggle",{Title="Zombie Text ESP",Description="shows important information about zombies through walls",Default=false}) local L=K.Visuals_ZombieESP:CreateColorpicker("ZombieTextColor",{Title="Text Color",Default=Color3.fromRGB(85,255,0)}) ab:OnChanged(function(M) if(not M)then m.TerminateById'ZombieTextToggle' return end m.New('ZombieTextToggle',function(N) while F.Loaded and task.wait()do for O,P in q.GetEnemies()do if aa[P]then continue end local Q=A(P,'HumanoidRootPart'); if(not Q)then continue end local R=r.SmartDraw('Text',{ Visible=false, Center=true, Outline=true, },function(R,S) if(not Q.Parent)then return end local T=A(P,'Humanoid'); if(not T)then return end local U,V=u.CurrentCamera:WorldToViewportPoint(Q.Position) R.Visible=V and ab.Value and T.Health>0; if V then local W=math.ceil(z:DistanceFromCharacter(Q.Position)or 0) R.Position=Vector2.new(U.X,U.Y) R.Text=string.format('Name: %s | Health: %s%% | Distance: %s', tostring(P.Name), tostring(math.floor(T.Health*100/T.MaxHealth)), tostring(W)) R.Color=L.Value end end) N:AddObject(P.AncestryChanged:Once(function() local S=aa[P]; if S then pcall(S.Destroy,S); aa[P]=nil end end)); aa[P]=R end end end):AddObject(function() for N,O in aa do pcall(O.Destroy,O)aa[N]=nil end end):Start() end) local M={}; local N=K.Visuals_PowerupESP:CreateToggle("PowerupTextToggle",{Title="Powerup Text ESP",Description="shows powerups through walls",Default=false}) local O=K.Visuals_PowerupESP:CreateColorpicker("PowerupTextColor",{Title="Text Color",Default=Color3.fromRGB(0,170,255)}) N:OnChanged(function(P) if(not P)then m.TerminateById'PowerupTextToggle' return end m.New('PowerupTextToggle',function(Q) while F.Loaded and task.wait()do for R,S in q.GetPowerups()do if M[S]then continue end local T=A(S,'Root'); if(not T)then continue end local U=r.SmartDraw('Text',{ Visible=false, Center=true, Outline=true, },function(U,V) if(not T.Parent)then return end local W,X=u.CurrentCamera:WorldToViewportPoint(T.Position) U.Visible=X and N.Value; if X then local Y=math.ceil(z:DistanceFromCharacter(T.Position)or 0) U.Position=Vector2.new(W.X,W.Y) U.Text=string.format('Powerup | Distance: %s', tostring(Y)) U.Color=O.Value end end) Q:AddObject(S.AncestryChanged:Once(function() local V=M[S]; if V then pcall(V.Destroy,V); M[S]=nil end end)); M[S]=U end end end):AddObject(function() for Q,R in M do pcall(R.Destroy,R)M[Q]=nil end end):Start() end) end,function(aa) K.Visuals_ZombieESP:CreateParagraph("AssetFuncVisuals_ZombieESP",{ Title="Unsupported Executor", TitleAlignment=Enum.TextXAlignment.Center, Content=string.format('your executor lacks features required for this feature: %s', tostring(table.concat(aa,", "))), ContentAlignment=Enum.TextXAlignment.Center }); K.Visuals_PowerupESP:CreateParagraph("AssetFuncVisuals_PowerupESP",{ Title="Unsupported Executor", TitleAlignment=Enum.TextXAlignment.Center, Content=string.format('your executor lacks features required for this feature: %s', tostring(table.concat(aa,", "))), ContentAlignment=Enum.TextXAlignment.Center }); end) end do local aa=K.Misc_Movement:CreateSlider("WalkSpeedSlider",{Title="Walk Speed",Description="studs per second",Default=16,Min=1,Max=256,Rounding=0}) local ab=K.Misc_Movement:CreateSlider("JumpSpeedSlider",{Title="Jump Power",Default=50,Min=1,Max=256,Rounding=0}) aa:OnChanged(function(L) m.TerminateById'WalkSpeedSlider' m.New('WalkSpeedSlider',function() z.Character.Humanoid.WalkSpeed=L end):AddObject(z.Character.Humanoid:GetPropertyChangedSignal'WalkSpeed':Connect(function() z.Character.Humanoid.WalkSpeed=L end)):Start() end) ab:OnChanged(function(L) m.TerminateById'JumpSpeedSlider' m.New('JumpSpeedSlider',function() z.Character.Humanoid.UseJumpPower=true z.Character.Humanoid.JumpPower=L end):AddObject(z.Character.Humanoid:GetPropertyChangedSignal'JumpPower':Connect(function() z.Character.Humanoid.UseJumpPower=true z.Character.Humanoid.JumpPower=L end)):Start() end) local L=K.Misc_Others:CreateToggle("AntiAFKToggle",{Title="Anti AFK",Description="prevents you from being kicked",Default=false}); L:OnChanged(r.AntiAFK) r.AssertFunctions({'firetouchinterest'},function() local M=K.Misc_Others:CreateToggle("AutoPickUpPowerups",{Title="Pickup Powerups",Description="automatically picks up powerups",Default=false}); local function N(O) local P=B(O,'TouchTransmitter',true); if P then firetouchinterest(P.Parent,z.Character.PrimaryPart,0) end end M:OnChanged(function(O) if not O then m.TerminateById"AutoPickUpPowerups" return end m.New("AutoPickUpPowerups",function(P) while F.Loaded and task.wait(1)do for Q,R in q.GetPowerups()do N(R) end end end):Start() end) end,function(M) K.Misc_Others:CreateParagraph("AssetFuncVisuals_AutoPickUpPowerups",{ Title="Unsupported Executor", TitleAlignment=Enum.TextXAlignment.Center, Content=string.format('your executor lacks features required for this feature: %s', tostring(table.concat(M,", "))), ContentAlignment=Enum.TextXAlignment.Center }); end) end do G:SetLibrary(F) H:SetLibrary(F) G:IgnoreThemeSettings() G:SetIgnoreIndexes{} H:SetFolder"StreliziaScriptHub" G:SetFolder("StreliziaScriptHub/"..game.PlaceId) H:BuildInterfaceSection(J.Settings) G:BuildConfigSection(J.Settings) I:SelectTab(1) F:Notify{ Title="strelizia.cc", Content="script loaded, enjoy <3", Duration=5 } F:ToggleTransparency(false) G:LoadAutoloadConfig() F.OnUnload:Connect(function() m.TerminateAll() local aa=A(y,'UIToggle') if aa then aa:Destroy()end; end) do m.New('DiscordJoinPrompt',function(aa) local ab=120 while true do local L,M=pcall(isfile,'StreliziaJoinedDiscord'); if L and M==true then break end; task.wait(ab) ab=ab*3 local N=I:Dialog{ Title="Discord", Content="Hey! Want to join our Discord for tons of giveaways, stay updated on script status, and hang out with the community?", Buttons={ { Title="Sure", Callback=function()r.PromptDiscordJoin('Vf4Wu3Cft7',true)pcall(writefile,'StreliziaJoinedDiscord','true')end }, { Title="No", Callback=function()end } } } N.Closed:Wait() end aa:Terminate() end):Start() end end end, Properties={ Name="Init" }, Reference=1, Children={ { ClassName="ModuleScript", Closure=function()local a={} function a.SetupLazyLoader(aa,ab) local b={}; for c,e in aa:GetChildren()do b[e.Name]=e end setmetatable(ab,{ __index=function(c,e) local f=b[e]; assert(f,string.format('[Library]: Cannot find module %s in %s',e,script.Name)) local g,i=pcall(require,f) assert(g,string.format('[Library]: Failed to Initalize Module %s in %s: %s',e,script.Name,tostring(i))) assert(typeof(i)=='function',string.format('[Library]: Module %s is NOT a Function',e)) local m,n=pcall(i,a) assert(m,string.format('[Library]: Failed to Load Module %s in %s: %s',e,script.Name,tostring(n))) rawset(c,e,n) return n end, }) end a.SetupLazyLoader(script,a) return a end, Properties={ Name="Library" }, Reference=2, Children={ { ClassName="ModuleScript", Closure=function()return function(a) local aa={}; a.SetupLazyLoader(script,aa) return aa end end, Properties={ Name="Libraries" }, Reference=45, Children={ { ClassName="ModuleScript", Closure=function()return function(a) local aa={}; a.SetupLazyLoader(script,aa) return aa end end, Properties={ Name="Special" }, Reference=58, Children={ { Closure=function()return function(a) local aa={} local ab=a.Libraries.Generic.Services local b=ab.ReplicatedStorage local c=ab.Players local e=a.Libraries.Generic.Promise local f=a.Libraries.Generic.Tree local m=a.Functions.Generic.GetTableSize local n=a.Functions.Generic.OutputMessage local function p() local q=c.LocalPlayer local r= q.Character local s={ SomePath=f.Find(b,'Shared/Remotes',1) } return s end local function q(r) local s={} for u,y in r do table.insert(s,e.new(function(z,A) local B,D=pcall(require,y); if B then z(D) else A(tostring(D)) end end):andThen(function(z)aa[u]=z end):catch(function(z) n('Error',string.format('Failed to require Game Module %s: %s', tostring(y.Name), tostring(z))) end)) end e.all(s):await() return aa end local function r() local s=p() if m(s)~=m(aa)then return q(s) end return aa end return table.freeze{ Get=r } end end, Properties={ Name="GameModules" }, Reference=59, ClassName="ModuleScript" } } }, { ClassName="ModuleScript", Closure=function()return function(a) local aa={}; a.SetupLazyLoader(script,aa) return aa end end, Properties={ Name="Generic" }, Reference=46, Children={ { Closure=function() return function(a) return setmetatable({},{ __index=function(aa,ab) local b,c=pcall(game.GetService,game,ab); if b then local e=cloneref(c) rawset(aa,ab,e) return e end return nil end, }) end end, Properties={ Name="Services" }, Reference=49, ClassName="ModuleScript" }, { ClassName="ModuleScript", Closure=function()return function(a) local aa=game:GetService"HttpService" local ab=require(script.Metatable) local b={can_spawn=true}; local c={} local e=function(e,f) local m=aa:GenerateGUID(false); local n={} n.running=false n.func=b.can_spawn and f or function()end n.index=e n.creation=DateTime.now().UnixTimestamp n.children={} c[m]=setmetatable(n,{ __index=ab, __tostring=function() return string.format('Thread(%s)', tostring(n.running and"Running"or"Stopped")) end, }) return n end local f=function() for f,m in c do m:Terminate() c[f]=nil end end local m=function(m) for n,p in c do if p.index~=m then continue end p:Terminate() c[n]=nil end end local n=function(n,p) b[n]=p end return table.freeze{ New=e, TerminateAll=f, TerminateById=m, SetOption=n } end end, Properties={ Name="Threading" }, Reference=55, Children={ { Closure=function()local a={} a.__index=a function a.Terminate(aa) pcall(task.cancel,aa.func) for ab,b in pairs(aa.children)do if typeof(b)=='RBXScriptConnection'then pcall(b.Disconnect,b) elseif(typeof(b)=='function')then pcall(task.spawn,b) elseif typeof(b)=='table'then local c=rawget(b,'Destroy')or rawget(b,'Disconnect'); if c then pcall(task.spawn,c,b) end elseif(pcall(function()return b.Destroy end))then pcall(b.Destroy,b) end aa.children[ab]=nil end aa.running=false end function a.Start(aa,...) local ab,b=pcall(task.spawn,aa.func,aa,...) if(not ab)then warn(string.format('Failed to start Thread %s (%s)',aa.index,tostring(b))) end aa.func=b aa.running=true return aa end function a.AddObject(aa,ab) table.insert(aa.children,ab) return aa end function a.GetAge(aa) return DateTime.now().UnixTimestamp-aa.creation end return a end, Properties={ Name="Metatable" }, Reference=56, ClassName="ModuleScript" } } }, { Closure=function()return function(a) local aa local function ab(b,...) local c=aa aa=nil b(...) aa=c end local function b(...) ab(...) while true do ab(coroutine.yield()) end end local c={} c.__index=c function c.Disconnect(e) if not e.Connected then return end e.Connected=false if e._signal._handlerListHead==e then e._signal._handlerListHead=e._next else local f=e._signal._handlerListHead while f and f._next~=e do f=f._next end if f then f._next=e._next end end end c.Destroy=c.Disconnect setmetatable(c,{ __index=function(e,f) error(("Attempt to get Connection::%s (not a valid member)"):format(tostring(f)),2) end, __newindex=function(e,f,m) error(("Attempt to set Connection::%s (not a valid member)"):format(tostring(f)),2) end, }) local f={} f.__index=f function f.new() return setmetatable({_handlerListHead=false,_proxyHandler=nil,_yieldedThreads=nil},f) end function f.Wrap(m) assert(typeof(m)=="RBXScriptSignal","Argument #1 to Signal.Wrap must be a RBXScriptSignal; got "..typeof(m)) local n=f.new() n._proxyHandler=m:Connect(function(...)n:Fire(...)end) return n end function f.Is(m) return type(m)=="table"and getmetatable(m)==f end function f.Connect(m,n) local p=setmetatable({Connected=true,_signal=m,_fn=n,_next=false},c) if m._handlerListHead then p._next=m._handlerListHead m._handlerListHead=p else m._handlerListHead=p end return p end function f.ConnectOnce(m,n)return m:Once(n)end function f.Once(m,n) local p local q=false p=m:Connect(function(...) if q then return end q=true p:Disconnect() n(...) end) return p end function f.GetConnections(m) local n={} local p=m._handlerListHead while p do table.insert(n,p) p=p._next end return n end function f.DisconnectAll(m) local n=m._handlerListHead while n do n.Connected=false n=n._next end m._handlerListHead=false local p=rawget(m,"_yieldedThreads") if p then for q in p do if coroutine.status(q)=="suspended"then warn(debug.traceback(q,"signal disconnected; yielded thread cancelled",2)) task.cancel(q) end end table.clear(m._yieldedThreads) end end function f.Fire(m,...) local n=m._handlerListHead while n do if n.Connected then if not aa then aa=coroutine.create(b) end task.spawn(aa,n._fn,...) end n=n._next end end function f.FireDeferred(m,...) local n=m._handlerListHead while n do local p=n task.defer(function(...) if p.Connected then p._fn(...)end end,...) n=n._next end end function f.Wait(m) local n=rawget(m,"_yieldedThreads") if not n then n={} rawset(m,"_yieldedThreads",n) end local p=coroutine.running() n[p]=true m:Once(function(...) n[p]=nil task.spawn(p,...) end) return coroutine.yield() end function f.Destroy(m) m:DisconnectAll() local n=rawget(m,"_proxyHandler") if n then n:Disconnect()end end setmetatable(f,{ __index=function(m,n) error(("Attempt to get Signal::%s (not a valid member)"):format(tostring(n)),2) end, __newindex=function(m,n,p) error(("Attempt to set Signal::%s (not a valid member)"):format(tostring(n)),2) end, }) return table.freeze{new=f.new,Wrap=f.Wrap,Is=f.Is} end end, Properties={ Name="Signal" }, Reference=52, ClassName="ModuleScript" }, { Closure=function()return function(a) local aa={_cached={}}; aa.__index=aa function aa.Get(ab) if aa._cached[ab]then return aa._cached[ab] else local b=setmetatable({_settings={}},{ __index=aa, __newindex=function(b,c,f) rawset(b,c,f) local n=b._settings.expiry if n then task.delay(n,rawset,b,c,nil) end end, }) aa._cached[ab]=b return b end end function aa.SetKeyExpiry(ab,b) ab._settings.expiry=tonumber(b) return ab end function aa.Clear(ab) for b,c in pairs(ab)do if b=='_settings'then continue end ab[b]=nil end return ab end return aa end end, Properties={ Name="Cache" }, Reference=50, ClassName="ModuleScript" }, { Closure=function()return function(a) local aa="Non-promise value passed into %s at index %s" local ab="Please pass a list of promises to %s" local b="Please pass a handler function to %s!" local c={__mode="k"} local function f(n) if type(n)=="function"then return true end if type(n)=="table"then local p=getmetatable(n) if p and type(rawget(p,"__call"))=="function"then return true end end return false end local function n(p,q) local r={} for s,u in ipairs(q)do r[u]=u end return setmetatable(r,{ __index=function(s,u) error(string.format("%s is not in %s!",u,p),2) end, __newindex=function() error(string.format("Creating new members in %s is not allowed!",p),2) end, }) end local p do p={ Kind=n("Promise.Error.Kind",{ "ExecutionError", "AlreadyCancelled", "NotResolvedInTime", "TimedOut", }), } p.__index=p function p.new(q,r) q=q or{} return setmetatable({ error=tostring(q.error)or"[This error has no error text.]", trace=q.trace, context=q.context, kind=q.kind, parent=r, createdTick=os.clock(), createdTrace=debug.traceback(), },p) end function p.is(q) if type(q)=="table"then local r=getmetatable(q) if type(r)=="table"then return rawget(q,"error")~=nil and type(rawget(r,"extend"))=="function" end end return false end function p.isKind(q,r) assert(r~=nil,"Argument #2 to Promise.Error.isKind must not be nil") return p.is(q)and q.kind==r end function p.extend(q,r) r=r or{} r.kind=r.kind or q.kind return p.new(r,q) end function p.getErrorChain(q) local r={q} while r[#r].parent do table.insert(r,r[#r].parent) end return r end function p.__tostring(q) local r={ string.format("-- Promise.Error(%s) --",q.kind or"?"), } for s,u in ipairs(q:getErrorChain())do table.insert( r, table.concat({ u.trace or u.error, u.context, },"\n") ) end return table.concat(r,"\n") end end local function q(...) return select("#",...),{...} end local function r(s,...) return s,select("#",...),{...} end local function s(u) assert(u~=nil,"traceback is nil") return function(y) if type(y)=="table"then return y end return p.new{ error=y, kind=p.Kind.ExecutionError, trace=debug.traceback(tostring(y),2), context="Promise created at:\n\n"..u, } end end local function u(y,z,...) return r(xpcall(z,s(y),...)) end local function y(z,A,B,D) return function(...) local E,F,G=u(z,A,...) if E then B(unpack(G,1,F)) else D(G[1]) end end end local function z(A) return next(A)==nil end local A={ Error=p, Status=n("Promise.Status",{"Started","Resolved","Rejected","Cancelled"}), _getTime=os.clock, _timeEvent=game:GetService"RunService".Heartbeat, _unhandledRejectionCallbacks={}, } A.prototype={} A.__index=A.prototype function A._new(B,D,E) if E~=nil and not A.is(E)then error("Argument #2 to Promise.new must be a promise or nil",2) end local F={ _thread=nil, _source=B, _status=A.Status.Started, _values=nil, _valuesLength=-1, _unhandledRejection=true, _queuedResolve={}, _queuedReject={}, _queuedFinally={}, _cancellationHook=nil, _parent=E, _consumers=setmetatable({},c), } if E and E._status==A.Status.Started then E._consumers[F]=true end setmetatable(F,A) local function G(...) F:_resolve(...) end local function H(...) F:_reject(...) end local function I(J) if J then if F._status==A.Status.Cancelled then J() else F._cancellationHook=J end end return F._status==A.Status.Cancelled end F._thread=coroutine.create(function()local J, K, L=u(F._source,D,G,H,I) if not J then H(L[1]) end end) task.spawn(F._thread) return F end function A.new(B) return A._new(debug.traceback(nil,2),B) end function A.__tostring(B) return string.format("Promise(%s)",B._status) end function A.defer(B) local D=debug.traceback(nil,2) local E E=A._new(D,function(F,G,H) local I I=A._timeEvent:Connect(function() I:Disconnect()local J, K, L=u(D,B,F,G,H) if not J then G(L[1]) end end) end) return E end A.async=A.defer function A.resolve(...) local B,D=q(...) return A._new(debug.traceback(nil,2),function(E) E(unpack(D,1,B)) end) end function A.reject(...) local B,D=q(...) return A._new(debug.traceback(nil,2),function(E,F) F(unpack(D,1,B)) end) end function A._try(B,D,...) local E,F=q(...) return A._new(B,function(G) G(D(unpack(F,1,E))) end) end function A.try(B,...) return A._try(debug.traceback(nil,2),B,...) end function A._all(B,D,E) if type(D)~="table"then error(string.format(ab,"Promise.all"),3) end for F,G in pairs(D)do if not A.is(G)then error(string.format(aa,"Promise.all",tostring(F)),3) end end if#D==0 or E==0 then return A.resolve{} end return A._new(B,function(F,G,H) local I={} local J={} local K=0 local L=0 local M=false local function N() for O,P in ipairs(J)do P:cancel() end end local function O(P,...) if M then return end K=K+1 if E==nil then I[P]=... else I[K]=... end if K>=(E or#D)then M=true F(I) N() end end H(N) for P,Q in ipairs(D)do J[P]=Q:andThen(function(...) O(P,...) end,function(...) L=L+1 if E==nil or#D-L<E then N() M=true G(...) end end) end if M then N() end end) end function A.all(B) return A._all(debug.traceback(nil,2),B) end function A.fold(B,D,E) assert(type(B)=="table","Bad argument #1 to Promise.fold: must be a table") assert(f(D),"Bad argument #2 to Promise.fold: must be a function") local F=A.resolve(E) return A.each(B,function(G,H) F=F:andThen(function(I) return D(I,G,H) end) end):andThen(function() return F end) end function A.some(B,D) assert(type(D)=="number","Bad argument #2 to Promise.some: must be a number") return A._all(debug.traceback(nil,2),B,D) end function A.any(B) return A._all(debug.traceback(nil,2),B,1):andThen(function(D) return D[1] end) end function A.allSettled(B) if type(B)~="table"then error(string.format(ab,"Promise.allSettled"),2) end for D,E in pairs(B)do if not A.is(E)then error(string.format(aa,"Promise.allSettled",tostring(D)),2) end end if#B==0 then return A.resolve{} end return A._new(debug.traceback(nil,2),function(D,E,F) local G={} local H={} local I=0 local function J(K,...) I=I+1 G[K]=... if I>=#B then D(G) end end F(function() for K,L in ipairs(H)do L:cancel() end end) for K,L in ipairs(B)do H[K]=L:finally(function(...) J(K,...) end) end end) end function A.race(B) assert(type(B)=="table",string.format(ab,"Promise.race")) for D,E in pairs(B)do assert(A.is(E),string.format(aa,"Promise.race",tostring(D))) end return A._new(debug.traceback(nil,2),function(D,E,F) local G={} local H=false local function I() for J,K in ipairs(G)do K:cancel() end end local function J(K) return function(...) I() H=true return K(...) end end if F(J(E))then return end for K,L in ipairs(B)do G[K]=L:andThen(J(D),J(E)) end if H then I() end end) end function A.each(B,D) assert(type(B)=="table",string.format(ab,"Promise.each")) assert(f(D),string.format(b,"Promise.each")) return A._new(debug.traceback(nil,2),function(E,F,G) local H={} local I={} local J=false local function K() for L,M in ipairs(I)do M:cancel() end end G(function() J=true K() end) local L={} for M,N in ipairs(B)do if A.is(N)then if N:getStatus()==A.Status.Cancelled then K() return F(p.new{ error="Promise is cancelled", kind=p.Kind.AlreadyCancelled, context=string.format( "The Promise that was part of the array at index %d passed into Promise.each was already cancelled when Promise.each began.\n\nThat Promise was created at:\n\n%s", M, N._source ), }) elseif N:getStatus()==A.Status.Rejected then K() return F(select(2,N:await())) end local O=N:andThen(function(...) return... end) table.insert(I,O) L[M]=O else L[M]=N end end for M,N in ipairs(L)do if A.is(N)then local O O,N=N:await() if not O then K() return F(N) end end if J then return end local O=A.resolve(D(N,M)) table.insert(I,O) local P,Q=O:await() if not P then K() return F(Q) end H[M]=Q end E(H) end) end function A.is(B) if type(B)~="table"then return false end local D=getmetatable(B) if D==A then return true elseif D==nil then return f(B.andThen) elseif type(D)=="table" and type(rawget(D,"__index"))=="table" and f(rawget(rawget(D,"__index"),"andThen")) then return true end return false end function A.promisify(B) return function(...) return A._try(debug.traceback(nil,2),B,...) end end do local B local D function A.delay(E) assert(type(E)=="number","Bad argument #1 to Promise.delay, must be a number.") if not(E>=1.6666666666666665E-2)or E==math.huge then E=1.6666666666666665E-2 end return A._new(debug.traceback(nil,2),function(F,G,H) local I=A._getTime() local J=I+E local K={ resolve=F, startTime=I, endTime=J, } if D==nil then B=K D=A._timeEvent:Connect(function() local L=A._getTime() while B~=nil and B.endTime<L do local M=B B=M.next if B==nil then D:Disconnect() D=nil else B.previous=nil end M.resolve(A._getTime()-M.startTime) end end) else if B.endTime<J then local L=B local M=L.next while M~=nil and M.endTime<J do L=M M=L.next end L.next=K K.previous=L if M~=nil then K.next=M M.previous=K end else K.next=B B.previous=K B=K end end H(function() local L=K.next if B==K then if L==nil then D:Disconnect() D=nil else L.previous=nil end B=L else local M=K.previous M.next=L if L~=nil then L.previous=M end end end) end) end end function A.prototype.timeout(B,D,E) local F=debug.traceback(nil,2) return A.race{ A.delay(D):andThen(function() return A.reject(E==nil and p.new{ kind=p.Kind.TimedOut, error="Timed out", context=string.format( "Timeout of %d seconds exceeded.\n:timeout() called at:\n\n%s", D, F ), }or E) end), B, } end function A.prototype.getStatus(B) return B._status end function A.prototype._andThen(B,D,E,F) B._unhandledRejection=false if B._status==A.Status.Cancelled then local G=A.new(function()end) G:cancel() return G end return A._new(D,function(G,H,I) local J=G if E then J=y(D,E,G,H) end local K=H if F then K=y(D,F,G,H) end if B._status==A.Status.Started then table.insert(B._queuedResolve,J) table.insert(B._queuedReject,K) I(function() if B._status==A.Status.Started then table.remove(B._queuedResolve,table.find(B._queuedResolve,J)) table.remove(B._queuedReject,table.find(B._queuedReject,K)) end end) elseif B._status==A.Status.Resolved then J(unpack(B._values,1,B._valuesLength)) elseif B._status==A.Status.Rejected then K(unpack(B._values,1,B._valuesLength)) end end,B) end function A.prototype.andThen(B,D,E) assert(D==nil or f(D),string.format(b,"Promise:andThen")) assert(E==nil or f(E),string.format(b,"Promise:andThen")) return B:_andThen(debug.traceback(nil,2),D,E) end function A.prototype.catch(B,D) assert(D==nil or f(D),string.format(b,"Promise:catch")) return B:_andThen(debug.traceback(nil,2),nil,D) end function A.prototype.tap(B,D) assert(f(D),string.format(b,"Promise:tap")) return B:_andThen(debug.traceback(nil,2),function(...) local E=D(...) if A.is(E)then local F,G=q(...) return E:andThen(function() return unpack(G,1,F) end) end return... end) end function A.prototype.andThenCall(B,D,...) assert(f(D),string.format(b,"Promise:andThenCall")) local E,F=q(...) return B:_andThen(debug.traceback(nil,2),function() return D(unpack(F,1,E)) end) end function A.prototype.andThenReturn(B,...) local D,E=q(...) return B:_andThen(debug.traceback(nil,2),function() return unpack(E,1,D) end) end function A.prototype.cancel(B) if B._status~=A.Status.Started then return end B._status=A.Status.Cancelled if B._cancellationHook then B._cancellationHook() end coroutine.close(B._thread) if B._parent then B._parent:_consumerCancelled(B) end for D in pairs(B._consumers)do D:cancel() end B:_finalize() end function A.prototype._consumerCancelled(B,D) if B._status~=A.Status.Started then return end B._consumers[D]=nil if next(B._consumers)==nil then B:cancel() end end function A.prototype._finally(B,D,E) B._unhandledRejection=false local F=A._new(D,function(F,G,H) local I H(function() B:_consumerCancelled(B) if I then I:cancel() end end) local J=F if E then J=function(...) local K=E(...) if A.is(K)then I=K K :finally(function(L) if L~=A.Status.Rejected then F(B) end end) :catch(function(...) G(...) end) else F(B) end end end if B._status==A.Status.Started then table.insert(B._queuedFinally,J) else J(B._status) end end) return F end function A.prototype.finally(B,D) assert(D==nil or f(D),string.format(b,"Promise:finally")) return B:_finally(debug.traceback(nil,2),D) end function A.prototype.finallyCall(B,D,...) assert(f(D),string.format(b,"Promise:finallyCall")) local E,F=q(...) return B:_finally(debug.traceback(nil,2),function() return D(unpack(F,1,E)) end) end function A.prototype.finallyReturn(B,...) local D,E=q(...) return B:_finally(debug.traceback(nil,2),function() return unpack(E,1,D) end) end function A.prototype.awaitStatus(B) B._unhandledRejection=false if B._status==A.Status.Started then local D=coroutine.running() B :finally(function() task.spawn(D) end) :catch( function()end ) coroutine.yield() end if B._status==A.Status.Resolved then return B._status,unpack(B._values,1,B._valuesLength) elseif B._status==A.Status.Rejected then return B._status,unpack(B._values,1,B._valuesLength) end return B._status end local function B(D,...) return D==A.Status.Resolved,... end function A.prototype.await(D) return B(D:awaitStatus()) end local function D(E,...) if E~=A.Status.Resolved then error((...)==nil and"Expected Promise rejected with no value."or(...),3) end return... end function A.prototype.expect(E) return D(E:awaitStatus()) end A.prototype.awaitValue=A.prototype.expect function A.prototype._unwrap(E) if E._status==A.Status.Started then error("Promise has not resolved or rejected.",2) end local F=E._status==A.Status.Resolved return F,unpack(E._values,1,E._valuesLength) end function A.prototype._resolve(E,...) if E._status~=A.Status.Started then if A.is((...))then (...):_consumerCancelled(E) end return end if A.is((...))then if select("#",...)>1 then local F=string.format([[When returning a Promise from andThen, extra arguments are discarded! See:%s]], E._source ) warn(F) end local F=... local G=F:andThen(function(...) E:_resolve(...) end,function(...) local G=F._values[1] if F._error then G=p.new{ error=F._error, kind=p.Kind.ExecutionError, context="[No stack trace available as this Promise originated from an older version of the Promise library (< v2)]", }end if p.isKind(G,p.Kind.ExecutionError)then return E:_reject(G:extend{ error="This Promise was chained to a Promise that errored.", trace="", context=string.format( "The Promise at:\n\n%s\n...Rejected because it was chained to the following Promise, which encountered an error:\n", E._source ), }) end E:_reject(...) end) if G._status==A.Status.Cancelled then E:cancel() elseif G._status==A.Status.Started then E._parent=G G._consumers[E]=true end return end E._status=A.Status.Resolved E._valuesLength,E._values=q(...) for F,G in ipairs(E._queuedResolve)do coroutine.wrap(G)(...) end E:_finalize() end function A.prototype._reject(E,...) if E._status~=A.Status.Started then return end E._status=A.Status.Rejected E._valuesLength,E._values=q(...) if not z(E._queuedReject)then for F,G in ipairs(E._queuedReject)do coroutine.wrap(G)(...) end else local F=tostring((...)) coroutine.wrap(function() A._timeEvent:Wait() if not E._unhandledRejection then return end local G=string.format("Unhandled Promise rejection:\n\n%s\n\n%s",F,E._source) for H,I in ipairs(A._unhandledRejectionCallbacks)do task.spawn(I,E,unpack(E._values,1,E._valuesLength)) end if A.TEST then return end warn(G) end)() end E:_finalize() end function A.prototype._finalize(E) for F,G in ipairs(E._queuedFinally)do coroutine.wrap(G)(E._status) end E._queuedFinally=nil E._queuedReject=nil E._queuedResolve=nil if not A.TEST then E._parent=nil E._consumers=nil end task.defer(coroutine.close,E._thread) end function A.prototype.now(E,F) local G=debug.traceback(nil,2) if E._status==A.Status.Resolved then return E:_andThen(G,function(...) return... end) else return A.reject(F==nil and p.new{ kind=p.Kind.NotResolvedInTime, error="This Promise was not resolved in time for :now()", context=":now() was called at:\n\n"..G, }or F) end end function A.retry(E,F,...) assert(f(E),"Parameter #1 to Promise.retry must be a function") assert(type(F)=="number","Parameter #2 to Promise.retry must be a number") local G,H={...},select("#",...) return A.resolve(E(...)):catch(function(...) if F>0 then return A.retry(E,F-1,unpack(G,1,H)) else return A.reject(...) end end) end function A.retryWithDelay(E,F,G,...) assert(f(E),"Parameter #1 to Promise.retry must be a function") assert(type(F)=="number","Parameter #2 (times) to Promise.retry must be a number") assert(type(G)=="number","Parameter #3 (seconds) to Promise.retry must be a number") local H,I={...},select("#",...) return A.resolve(E(...)):catch(function(...) if F>0 then A.delay(G):await() return A.retryWithDelay(E,F-1,G,unpack(H,1,I)) else return A.reject(...) end end) end function A.fromEvent(E,F) F=F or function() return true end return A._new(debug.traceback(nil,2),function(G,H,I) local J local K=false local function L() J:Disconnect() J=nil end J=E:Connect(function(...) local M=F(...) if M==true then G(...) if J then L() else K=true end elseif type(M)~="boolean"then error"Promise.fromEvent predicate should always return a boolean" end end) if K and J then return L() end I(L) end) end function A.onUnhandledRejection(E) table.insert(A._unhandledRejectionCallbacks,E) return function() local F=table.find(A._unhandledRejectionCallbacks,E) if F then table.remove(A._unhandledRejectionCallbacks,F) end end end return A end end, Properties={ Name="Promise" }, Reference=51, ClassName="ModuleScript" }, { Closure=function()return function(a) local aa={} local ab={Fluent= 97404758083545,SaveManager= 132828910264093,ThemeManager= 72525158718178; }; local b=a.Functions.Generic.GetTableSize; local c=a.Libraries.Generic.Promise local f=a.Functions.Generic.OutputMessage local n=function() local n=os.clock() local p={} for q,r in ab do table.insert(p,c.new(function(s,u) local y,z=pcall(game.GetObjects,game,"rbxassetid://"..r) if y then if a.Debug then f('Success',string.format('Successfully loaded Interface Module %s: %ss Elapsed', tostring(q), tostring(os.clock()-n))) end s(loadstring(z[1].Source)()) else u(tostring(z)) end end):andThen(function(s) aa[q]=s end):catch(function(s) f('Error',string.format('Failed to load Interface Module %s: %s', tostring(q), tostring(s))) end)) end c.all(p):await() if a.Debug then f('Info',string.format('Took %ss to load Interface Class (%s Modules)', tostring(os.clock()-n), tostring(b(ab)))) end return aa end return{ Get=function() if(b(ab)~=b(aa))then n() end return aa end, } end end, Properties={ Name="Interface" }, Reference=57, ClassName="ModuleScript" }, { Closure=function()return function(a) local aa=game:GetService"RunService" local ab=newproxy() local b=newproxy() local c=table.freeze{"Destroy","Disconnect","destroy","disconnect"} local function f(n,p) local q=typeof(n) if q=="function"then return ab elseif q=="thread"then return b end if p then return p end if q=="Instance"then return"Destroy" elseif q=="RBXScriptConnection"then return"Disconnect" elseif q=="table"then for r,s in c do if typeof(n[s])=="function"then return s end end end error(string.format('failed to get cleanup function for object %s: %s',tostring(q),tostring(n)),3) end local function n(p) if typeof(p)~="table" or typeof(p.getStatus)~="function" or typeof(p.finally)~="function" or typeof(p.cancel)~="function" then error("did not receive a promise as an argument",3) end end local p={} p.__index=p function p.new() local q=setmetatable({},p) q._objects={} q._cleaning=false return q end function p.Add(q,r,s) if q._cleaning then error("cannot call trove:Add() while cleaning",2) end local u=f(r,s) table.insert(q._objects,{r,u}) return r end function p.Clone(q,r) if q._cleaning then error("cannot call trove:Clone() while cleaning",2) end return q:Add(r:Clone()) end function p.Construct(q,r,...) if q._cleaning then error("Cannot call trove:Construct() while cleaning",2) end local s local u=type(r) if u=="table"then s=r.new(...) elseif u=="function"then s=r(...) end return q:Add(s) end function p.Connect(q,r,s) if q._cleaning then error("Cannot call trove:Connect() while cleaning",2) end return q:Add(r:Connect(s)) end function p.BindToRenderStep(q,r,s,u) if q._cleaning then error("cannot call trove:BindToRenderStep() while cleaning",2) end aa:BindToRenderStep(r,s,u) q:Add(function() aa:UnbindFromRenderStep(r) end) end function p.AddPromise(q,r) if q._cleaning then error("cannot call trove:AddPromise() while cleaning",2) end n(r) if r:getStatus()=="Started"then r:finally(function() if q._cleaning then return end q:_findAndRemoveFromObjects(r,false) end) q:Add(r,"cancel") end return r end function p.Remove(q,r) if q._cleaning then error("cannot call trove:Remove() while cleaning",2) end return q:_findAndRemoveFromObjects(r,true) end function p.Extend(q) if q._cleaning then error("cannot call trove:Extend() while cleaning",2) end return q:Construct(p) end function p.Clean(q) if q._cleaning then return end q._cleaning=true for r,s in q._objects do q:_cleanupObject(s[1],s[2]) end table.clear(q._objects) q._cleaning=false end function p.WrapClean(q) return function() q:Clean() end end function p._findAndRemoveFromObjects(q,r,s) local u=q._objects for y,z in u do if z[1]==r then local A=#u u[y]=u[A] u[A]=nil if s then q:_cleanupObject(z[1],z[2]) end return true end end return false end function p._cleanupObject(q,r,s) if s==ab then task.spawn(r) elseif s==b then pcall(task.cancel,r) else r[s](r) end end function p.AttachToInstance(q,r) if q._cleaning then error("cannot call trove:AttachToInstance() while cleaning",2) elseif not r:IsDescendantOf(game)then error("instance is not a descendant of the game hierarchy",2) end return q:Connect(r.Destroying,function() q:Destroy() end) end function p.Destroy(q) q:Clean() end return{ new=p.new, } end end, Properties={ Name="Trove" }, Reference=54, ClassName="ModuleScript" }, { Closure=function() return function(a) return{ LRM_IsUserPremium=LRM_IsUserPremium or true, LRM_LinkedDiscordID=LRM_LinkedDiscordID or 1132756183229419661, LRM_ScriptName=LRM_ScriptName or"strelizia.cc", LRM_TotalExecutions=LRM_TotalExecutions or 5, LRM_SecondsLeft=LRM_SecondsLeft or 300, LRM_UserNote=LRM_UserNote or"Developer | Premium | Lifetime", LRM_ScriptVersion=LRM_ScriptVersion or"0.0.0.1" } end end, Properties={ Name="LRM_Variables" }, Reference=47, ClassName="ModuleScript" }, { Closure=function()return function(a) local aa=a.Libraries.Generic.Cache; local ab=aa.Get'Actions' local function b(c,f) if(typeof(c)=='table')then for n,p in c do ab[p]=f end else ab[c]=f end return true end local function c(f) if(typeof(f)=='table')then for n,p in f do if(not ab[p])then continue end return true end return false else return ab[f] end end return table.freeze{SetActionState=b,GetActionState=c} end end, Properties={ Name="Actions" }, Reference=48, ClassName="ModuleScript" }, { Closure=function()return function(a) local aa={} local ab={Delimiter="/"}; local function b(c,f,n) local p=aa[c]; if p then return p end local q=string.split(c,ab.Delimiter); for r,s in q do f=f:FindFirstChild(s)or(n and f:WaitForChild(s,n))or nil; if(not f)then return nil end end aa[c]=f return f end function ab.SetDelimiter(c) ab.Delimiter=c or"/" end function ab.Find(c,f,n) local p=b(f,c,n); return p end return ab end end, Properties={ Name="Tree" }, Reference=53, ClassName="ModuleScript" } } } } }, { ClassName="ModuleScript", Closure=function()return function(a) local aa={}; a.SetupLazyLoader(script,aa) return aa end end, Properties={ Name="Functions" }, Reference=3, Children={ { ClassName="ModuleScript", Closure=function()return function(a) local aa={}; a.SetupLazyLoader(script,aa) return aa end end, Properties={ Name="Generic" }, Reference=4, Children={ { Closure=function()return function(a) local aa=game.FindFirstChild return function(ab) local b=ab.Character if(not b)then return false end local c=b.PrimaryPart if(not c)then return false end local f=aa(b,"Humanoid") if(not f)or(f.Health<=0)then return false end return true end end end, Properties={ Name="IsAlive" }, Reference=10, ClassName="ModuleScript" }, { Closure=function()return function(a) local aa=a.Libraries.Generic.Services local ab=a.Libraries.Generic.Cache local b=aa.MarketplaceService local c=ab.Get"GameInfoCache":SetKeyExpiry(180) return function(f) if c[tostring(f)]then return c[tostring(f)] end local n,p=pcall(b.GetProductInfo,b,f,Enum.InfoType.Asset) if n then c[tostring(f)]=p return p end return nil end end end, Properties={ Name="GetGameInfo" }, Reference=5, ClassName="ModuleScript" }, { Closure=function()return function(a) local aa; local ab=a.Libraries.Generic.Services local b=ab.VirtualUser local c=ab.Players local f=Random.new() local n=c.LocalPlayer return function(p) if p==false then if aa then aa:Disconnect()end; return true end if aa then return true end aa=n.Idled:Connect(function() local q=workspace.CurrentCamera b:Button2Down(Vector2.new(0,0),q.CFrame) task.wait(f:NextNumber(0,1)) b:Button2Up(Vector2.new(0,0),q.CFrame) end) end end end, Properties={ Name="AntiAFK" }, Reference=9, ClassName="ModuleScript" }, { Closure=function()return function(a) return(syn and syn.request)or(http and http.request)or httprequest or request or function()return end end end, Properties={ Name="HttpRequest" }, Reference=14, ClassName="ModuleScript" }, { Closure=function()return function(a) return function(aa,ab) local b=ab.Retries or 2; local c=ab.Arguments or{}; local f=ab.RetryDelay or 0; local n,p; for q=1,b do n,p=pcall(aa,unpack(c)); if n and p==true then break end task.wait(f) end return n,p end end end, Properties={ Name="Retry" }, Reference=21, ClassName="ModuleScript" }, { Closure=function()return function(a) local aa={ Info='🔵', Warn='🟠', Success='🟢', Error='🔴' } local function ab(b,c) local f=os.date"*t" string.format("%s:%s:%s",f.hour,f.min,f.sec) print(string.format("%s | [Library]: %s",aa[b],c)) end return ab end end, Properties={ Name="OutputMessage" }, Reference=20, ClassName="ModuleScript" }, { Closure=function()return function(a) local aa=a.Functions.Generic.GetPing; return function(ab,b) local c=aa(); if c<ab then return end while aa()>b do task.wait(0.2) end end end end, Properties={ Name="HaltLatency" }, Reference=37, ClassName="ModuleScript" }, { Closure=function()return function(a) return function(aa,ab,b,c) local f=ab or 3 local n=b or 1 local p=c or{} local q=0; while q<f do local r,s=pcall(aa,unpack(p)) if r and s then return true end q=q+n;task.wait(n) end return false end end end, Properties={ Name="Timeout" }, Reference=12, ClassName="ModuleScript" }, { Closure=function()return function(a) local aa=a.Libraries.Generic.Services local ab=Drawing; local b=aa.RunService return function(c,f,n) if(not ab)then return end local p=ab.new(c); local q={Drawing=p} for r,s in f do p[r]=s end q.Updater=b.Heartbeat:Connect(function(r) n(p,r) end) function q.Destroy() if(not q.Drawing)then return end pcall(q.Drawing.Destroy,q.Drawing) pcall(q.Updater.Disconnect,q.Updater); q.Drawing=nil q.Updater=nil return end return q end end end, Properties={ Name="SmartDraw" }, Reference=26, ClassName="ModuleScript" }, { Closure=function()return function(a) local aa=a.Libraries.Generic.Services; local ab=aa.Stats local b=ab.Network.ServerStatsItem["Data Ping"] return function()local c, f=pcall(b.GetValue,b); return f or 0 end end end, Properties={ Name="GetPing" }, Reference=38, ClassName="ModuleScript" }, { Closure=function()return function(a) local aa=a.Libraries.Generic.Cache local ab=aa.Get'ScriptCache' return function() local b=ab.InitTime if(not b)then return 0 end return DateTime.now().UnixTimestamp-b end end end, Properties={ Name="GetUptime" }, Reference=7, ClassName="ModuleScript" }, { Closure=function()return function(a) local aa=a.Libraries.Generic.Services local ab=aa.HttpService local function b(c,f) f=f or{} local n=typeof(c); if n=='table'then if f[c]then return f[c] else local p={} f[c]=p for q,r in next,c do p[b(q,f)]=b(r,f) end; setmetatable(p,b(getmetatable(c),f)) return p end else return c end end return function(c,f) if f then return(b(c)) else return ab:JSONDecode(ab:JSONEncode(c)) end end end end, Properties={ Name="TableClone" }, Reference=23, ClassName="ModuleScript" }, { Closure=function()return function(a) local aa={} return function(ab) local b=tostring(ab); if aa[b]then return aa[b]end local c=b:reverse():gsub("%d%d%d","%1,"):reverse():gsub("^,",""); aa[b]=c return c end end end, Properties={ Name="CommaNumber" }, Reference=13, ClassName="ModuleScript" }, { Closure=function() return function(a) local aa=a.Functions.Generic.HttpRequest local ab=a.Libraries.Generic.Services local b=ab.HttpService return function(c,f) if f then setclipboard("https://www.discord.gg/"..c) end if(not aa)then return false end aa{ Url="http://127.0.0.1:6463/rpc?v=1", Method="POST", Headers={ ["Content-Type"]="application/json",Origin= "https://discord.com" }, Body=b:JSONEncode{ cmd="INVITE_BROWSER", args={ code=c }, nonce=b:GenerateGUID(false) } } return true end end end, Properties={ Name="PromptDiscordJoin" }, Reference=15, ClassName="ModuleScript" }, { Closure=function()return function(a) local aa=a.Libraries.Generic.Services local ab=aa.Players local b=ab.LocalPlayer return function(c) local f=b.Character; if(not f)or(not f.HumanoidRootPart)then return end f.HumanoidRootPart.Anchored=c end end end, Properties={ Name="SetPlayerAnchored" }, Reference=11, ClassName="ModuleScript" }, { Closure=function()return function(a) return function(...) local aa={} for ab,b in pairs{...}do for c,f in b do aa[c]=f end end return aa end end end, Properties={ Name="JoinDictionaries" }, Reference=24, ClassName="ModuleScript" }, { ClassName="ModuleScript", Closure=function()return function(a) local aa=game.FindFirstChild local ab={}; local function b(c,f) local n=(not f and ab[c]); if n then return n end;local p, q=pcall(require(c),a); ab[c]=q return q end return function(c,f,n,p) local q=true local r={ [true]=f, [false]=n } for s,u in c do local y=aa(script,u) if(not y)then continue end q=b(y,p); if(not q)then break end end if r[q]then pcall(r[q],c) end return q end end end, Properties={ Name="AssertFunctions" }, Reference=27, Children={ { Closure=function()local function a() return nil end return function(aa) local ab=newcclosure if not ab then return false end local b,c=pcall(ab,a) if not b or typeof(c)~="function"or c==a then return false end return true end end, Properties={ Name="newcclosure" }, Reference=33, ClassName="ModuleScript" }, { Closure=function()local a=function()return end; return function(aa) local ab=islclosure if not ab then return false end local b,c=pcall(ab,a); if not b or c~=true then return false end local f=print; if(not f)then return false end local n,p=pcall(ab,f); if not n or p==true then return false end return true end end, Properties={ Name="islclosure" }, Reference=31, ClassName="ModuleScript" }, { Closure=function()local function a() local aa="Constant" return aa end return function(aa) local ab=(debug and debug.getconstants)or getconstants if not ab then return false end local f,n=pcall(ab,a) if not f or(typeof(n)~='table')or#n~=1 or n[1]~='Constant'then return false end return true end end, Properties={ Name="getconstants" }, Reference=29, ClassName="ModuleScript" }, { Closure=function()local a=setmetatable({},{ __index=function(a,aa) return false end, }) local function aa(ab,f) return ab[f] end return function(ab) local f=hookmetamethod; if(not f)then return false end local n, p=pcall(f,a,"__index",function()return true end); if(not n)then return false end local q,r=pcall(aa,a,'Test'); if(not q)or r~=true then return false end return true end end, Properties={ Name="hookmetamethod" }, Reference=34, ClassName="ModuleScript" }, { Closure=function()local a=setmetatable({},{}) local aa=setmetatable({},{__metatable="locked"}) local ab=getmetatable(a) return function(f) local q=getrawmetatable if not q then return false end local r,s=pcall(q,a); if(not r)or s~=ab then return false end local u,y=pcall(q,aa); if(not u)or(y.__metatable~='locked')then return false end return true end end, Properties={ Name="getrawmetatable" }, Reference=30, ClassName="ModuleScript" }, { Closure=function()return function(a) local aa=Drawing; if(not aa)or(not aa.new)then return false end local ab,f=pcall(aa.new,'Circle'); if(not ab)or typeof(f)~='DrawingObject'then return false end local q, u=pcall(f.Destroy,f) if(not q)then return false end return true end end, Properties={ Name="drawing" }, Reference=35, ClassName="ModuleScript" }, { Closure=function()local a={1,2,3,'Hi','Test'} local function aa() local q,u,y,z=table.unpack(a) return table.pack(q,u,y,z) end return function(q) local u=debug and debug.getupvalues or getupvalues; if(not u)then return false end local y,z=pcall(u,aa) if not y or typeof(z)~='table'or typeof(z[1])~='table'or(table.unpack(z[1])~=table.unpack(a))then return false end return true end end, Properties={ Name="getupvalues" }, Reference=32, ClassName="ModuleScript" }, { Closure=function()Instance.new"Part" return function(a) local aa=firetouchinterest if not aa then return false end return true end end, Properties={ Name="firetouchinterest" }, Reference=36, ClassName="ModuleScript" }, { Closure=function()local a={ Param={ Function=function(a,aa,q,u)local y=5;return y end, Expected={source="=";what="Lua";numparams=4;func=nil;short_src="";name="Function";is_vararg=0;nups=0;} }, Lua={ Function=function()return'Hi i am lua indeed'end, Expected={source="=";what="Lua";numparams=0;func=nil;short_src="";name="Function";is_vararg=0;nups=0;} }, C={ Function=print or function()return'well this aint no C'end, Expected={source="=[C]";what="C";numparams=0;func=nil;short_src="[C]";currentline=-1;name="print";is_vararg=1;nups=0;} } } return function(aa) local q=(debug and debug.getinfo)or getinfo if not q then return false end for u,y in a do y.Expected.func=y.Function; local z,A=pcall(q,y.Function); if not z or(typeof(A)~='table')then return false end for B,D in y.Expected do if(A[B]==D)then continue end return false end end return true end end, Properties={ Name="debug_getinfo" }, Reference=28, ClassName="ModuleScript" } } }, { Closure=function()return function(a) local aa=a.Libraries.Generic.Services local q=aa.Players local u=aa.Workspace local y=q.LocalPlayer local z=u.CurrentCamera local A=u.Raycast return function(B,D,E) local F=y.Character; if(not F)then return false end E=E or{} local G=E.Ignore or{} local H=E.ParentMatching or false local I=D or z.CFrame.Position local J=(B.Position-I).Unit; local K=RaycastParams.new(); K.FilterType=Enum.RaycastFilterType.Exclude K:AddToFilter(y.Character) for L,M in G do if(typeof(M)~='Instance')then continue end K:AddToFilter(M) end local L=A(u,I,J*1000,K); if L and L.Instance==B then return true end if H and L.Instance.Parent==B.Parent then return true end return false end end end, Properties={ Name="IsPartVisible" }, Reference=17, ClassName="ModuleScript" }, { Closure=function()return function(a) local aa=a.Libraries.Generic.Services; local q=aa.GuiService return function() local u=workspace.CurrentCamera local y=u.ViewportSize local z,A=q:GetGuiInset() return Vector2.new(y.X,y.Y),z,A end end end, Properties={ Name="GetScreenSize" }, Reference=19, ClassName="ModuleScript" }, { Closure=function()return function(a) return function(aa) local q=0; for u,y in aa do q=q+1 end return q end end end, Properties={ Name="GetTableSize" }, Reference=6, ClassName="ModuleScript" }, { Closure=function()return function(a) local aa=a.Functions.Generic.OutputMessage return function(q) local u=os.clock(); return function() local y=math.ceil((os.clock()-u)*1000); if y>250 and a.Debug then aa('Warn',string.format('Benchmark %s took long to complete (%sms)', tostring(q), tostring(y))) end return y end end end end, Properties={ Name="Benchmark" }, Reference=22, ClassName="ModuleScript" }, { Closure=function()return function(a) return function(...) local aa={}; for q,u in{...}do for y,z in u do table.insert(aa,z) end end end end end, Properties={ Name="JoinArrays" }, Reference=25, ClassName="ModuleScript" }, { Closure=function()return function(a) return function(aa,q) local u=Instance.new(aa); for y,z in q do u[y]=z end return u end end end, Properties={ Name="CreateInstance" }, Reference=18, ClassName="ModuleScript" }, { Closure=function()return function(a) local aa={}; return function(q) local u=aa[tostring(q)]; if u then return u end local y=(q-q%60)/60 q=q-y*60 local z=(y-y%60)/60 y=y-z*60 local A=string.format("%02i",z)..":"..string.format("%02i",y)..":"..string.format("%02i",q) aa[tostring(q)]=A return A end end end, Properties={ Name="FormatHms" }, Reference=8, ClassName="ModuleScript" }, { Closure=function()return function(a) local aa=a.Libraries.Generic.Services; local q=aa.Players local u=q.LocalPlayer local y=u:GetMouse() return function() return Vector2.new(y.X,y.Y) end end end, Properties={ Name="GetMousePosition" }, Reference=16, ClassName="ModuleScript" } } }, { ClassName="ModuleScript", Closure=function()return function(a) local aa={}; a.SetupLazyLoader(script,aa) return aa end end, Properties={ Name="Special" }, Reference=39, Children={ { Closure=function()return function(a) local aa=a.Libraries.Generic.Services local q=a.Functions.Generic.IsAlive local u=game.FindFirstChildWhichIsA local y=game.FindFirstChild local z=game.GetAttribute local A=aa.Players local B=A.LocalPlayer return function() if(not q(B))then return nil end local D=B.Character; local E=u(D,'Tool'); if E and y(E,'Event')and z(E,'Damage')then return E end return nil end end end, Properties={ Name="GetWeapon" }, Reference=41, ClassName="ModuleScript" }, { Closure=function()return function(a) local aa=a.Libraries.Generic.Services local q=aa.UserInputService local u= aa.CollectionService local y=aa.Players local z=a.Functions.Generic.IsPartVisible local A=a.Functions.Special.GetEnemies local B=y.LocalPlayer local D=game.FindFirstChild local E=game.FindFirstChildWhichIsA local F=B.DistanceFromCharacter local G=workspace.CurrentCamera.WorldToViewportPoint local H=q.GetMouseLocation return function(I) local J,K=I or math.huge; local L=A() if(not L)then return nil end for M,N in L do local O=D(N,'Head') if(not O)then continue end local P=E(N,'Humanoid') if(not P)or(P.Health<=0)then continue end local Q=D(N,"Appearance"); Q=(Q and Q:GetChildren())or{} local R=F(B,O.Position) if R>600 then continue end local S,T=G(workspace.CurrentCamera,O.Position); if(not T)then continue end if(not z(O,B.Character.PrimaryPart.Position,{Ignore=Q,ParentMatching=true}))then continue end local U=(H(q)-Vector2.new(S.X,S.Y)).Magnitude; if J>U then J=U K=N end end return K,J end end end, Properties={ Name="GetClosestEnemyToMouse" }, Reference=42, ClassName="ModuleScript" }, { Closure=function()return function(a) local aa=a.Libraries.Generic.Services local q=aa.Workspace local u=game.FindFirstChild local y=game.GetChildren return function() local z=u(q,'Game'); if z then local A=u(z,'Powerups') return(A and y(A))or nil end return nil end end end, Properties={ Name="GetPowerups" }, Reference=44, ClassName="ModuleScript" }, { Closure=function()return function(a) local aa=a.Libraries.Generic.Services local q=aa.Workspace local u=game.FindFirstChild local y=game.GetChildren return function() local z=u(q,'Game'); if z then local A=u(z,'Zombies') return(A and y(A))or nil end return nil end end end, Properties={ Name="GetEnemies" }, Reference=40, ClassName="ModuleScript" }, { Closure=function()return function(a) local aa=a.Functions.Generic.IsPartVisible local q=game.FindFirstChild return function(u,y,z,A) local B,D=false; local E=0; while E<360 do if(not u.Parent)then break end local F=q(u,'HumanoidRootPart') if(not F)then break end local G=F.Position+Vector3.new(math.cos(E)*y,0,math.sin(E)*y); if aa(u.Head,G,A)then B,D=true,G break end E=E+z task.wait() end return B,D,E end end end, Properties={ Name="ResolveTeleportDistance" }, Reference=43, ClassName="ModuleScript" } } } } } } } } } } do local aa,q,u,y,z,A,B,D,E,F,G,H,I,J,K,L='0.4.2',Flags or{},script,next,unpack,table,require,type,pcall,getfenv,setfenv,setmetatable,rawget,coroutine,task,Instance local M,N,O,P,Q,R,S,T,U=A.insert,A.freeze,J.wrap,K.defer,K.cancel,L.new,(q.ContextualExecution==nil and true)or q.ContextualExecution do if S then local V=game:GetService'RunService'T=V:IsServer()U=V:IsClient()end end local V,W,X,Y,Z,_={},{},{},{},{},{}local function ac(ad)local ae,af=E(R,ad.ClassName)if not ae then return end V[ad.Reference]=af if ad.Closure then X[af]=ad.Closure if af:IsA'BaseScript'then M(Z,af)end end if ad.Properties then for ag,ah in y,ad.Properties do E(function()af[ag]=ah end)end end if ad.RefProperties then for ag,ah in y,ad.RefProperties do M(W,{InstanceObject=af,Property=ag,ReferenceId=ah})end end if ad.Attributes then for ag,ah in y,ad.Attributes do E(af.SetAttribute,af,ag,ah)end end if ad.Children then for ag,ah in y,ad.Children do local ai=ac(ah)if ai then ai.Parent=af end end end return af end local ad={}do for ae,af in y,a do M(ad,ac(af))end end local ae=F(0)local function af(ag)local ah=Y[ag]if ag.ClassName=='ModuleScript'and ah then return z(ah)end local ai=X[ag]if not ai then return end do local aj local ak={maui=N{Version=aa,Script=u,Shared=_,GetScript=function()return u end,GetShared=function()return _ end},script=ag,require=function(ak,...)if ak and ak.ClassName=='ModuleScript'and X[ak]then return af(ak)end return B(ak,...)end,getfenv=function(ak,...)if D(ak)=='number'and ak>=0 then if ak==0 then return aj else ak=ak+1 local al,am=E(F,ak)if al and am==ae then return aj end end end return F(ak,...)end,setfenv=function(ak,al,...)if D(ak)=='number'and ak>=0 then if ak==0 then return G(aj,al)else ak=ak+1 local am,an=E(F,ak)if am and an==ae then return G(aj,al)end end end return G(ak,al,...)end}aj=H({},{__index=function(al,am)local an=I(aj,am)if an~=nil then return an end local ao=ak[am]if ao~=nil then return ao end return ae[am]end})G(ai,aj)end local aj=O(ai)if ag:IsA'BaseScript'then local ak=(not S or not ag.Disabled)and P(aj)if S then local al al=ag:GetPropertyChangedSignal'Disabled':Connect(function(am)al:Disconnect()if am==false then af(ag)else E(Q,ak)end end)end return else local ak={aj()}Y[ag]=ak return z(ak)end end for ag,ah in y,W do E(function()ah.InstanceObject[ah.Property]=V[ah.ReferenceId]end)end for ag,ah in y,Z do if not S or((T and ah.ClassName=='Script')or(U and ah.ClassName=='LocalScript'))then af(ah)end end if q.ReturnMainModule==nil or q.ReturnMainModule then local ag do for ah,ai in y,ad do if ai.ClassName=='ModuleScript'and ai.Name=='MainModule'then ag=ai break end end end if ag then return af(ag)end end end
